{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap b40b89f0cd5d9ec5565b","webpack:///./public/fonts/slkscr-webfont.eot","webpack:///./src/styles/game.css?abf4","webpack:///./~/svg.js/dist/svg.js","webpack:///./src/index.js","webpack:///./src/styles/game.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./public/fonts/slkscr-webfont.svg","webpack:///./public/fonts/slkscr-webfont.ttf","webpack:///./public/fonts/slkscr-webfont.woff","webpack:///./~/style-loader/addStyles.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","content","locals","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","undefined","document","window","this","pathRegReplace","a","b","replace","SVG","regex","dots","array_clone","arr","clone","slice","length","Array","isArray","is","el","obj","matches","selector","matchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","camelCase","toLowerCase","g","toUpperCase","capitalize","charAt","fullHex","hex","substring","join","compToHex","comp","toString","proportionalSize","element","width","height","box","bbox","deltaTransformPoint","matrix","x","y","arrayToMatrix","e","f","parseMatrix","Matrix","ensureCentre","target","cx","cy","arrayToString","il","assignNewId","node","childNodes","SVGElement","adopt","id","eid","nodeName","fullBox","w","h","x2","y2","idFromReference","url","match","reference","supported","Doc","parser","draw","prepare","ns","xmlns","xlink","svgjs","createElementNS","createSVGRect","did","create","setAttribute","extend","methods","key","arguments","pop","Set","inherit","invent","config","initializer","constructor","construct","parent","Container","instance","parentNode","Nested","Gradient","Element","type","namespace","defs","setData","JSON","parse","getAttribute","body","getElementsByTagName","documentElement","nested","size","style","poly","polyline","path","native","addEventListener","numberAndUnit","rgb","transforms","whitespace","isHex","isRgb","isCss","isBlank","isNumber","isPercent","isImage","delimiter","hyphen","pathLetters","isPathLetter","numbersWithDots","utils","map","array","block","result","push","filter","radians","Math","PI","degrees","r","filterSVGElements","nodes","defaults","attrs","fill-opacity","stroke-opacity","stroke-width","stroke-linejoin","stroke-linecap","fill","stroke","opacity","rx","ry","offset","stop-opacity","stop-color","font-size","font-family","text-anchor","Color","color","test","exec","parseInt","toHex","toRgb","brightness","morph","destination","at","pos","isColor","fallback","valueOf","lastValue","lastDestination","settle","seen","indexOf","split","string","trim","parseFloat","reverse","PointArray","toLine","x1","y1","points","len","move","isNaN","getBBox","pathHandlers","M","p0","L","H","V","C","S","Q","T","Z","A","mlhvqtcsa","j","jl","PathArray","equalCommands","pathArray","sourceArray","destinationArray","paramCnt","reduce","prev","curr","concat","Point","index","Number","unit","isFinite","toJSON","plus","number","minus","times","divide","to","relative","_stroke","_event","dom","attr","center","withData","writeDataToDom","cloneNode","add","after","remove","removeElement","addTo","put","putIn","inside","show","hide","visible","classes","hasClass","addClass","removeClass","toggleClass","doc","parents","svg","well","createElement","Parent","appendChild","innerHTML","firstChild","each","lines","removeAttribute","keys","stringify","easing","-","<>","cos",">","sin","<","from","MorphObj","Situation","init","reversed","reversing","duration","delay","start","Date","finish","ease","loop","loops","animations","styles","once","FX","_target","situations","active","situation","paused","lastPos","absPos","_speed","animate","queue","timeToAbsPos","timestamp","absPosToTime","startAnimFrame","stopAnimFrame","animationFrame","requestAnimationFrame","step","bind","cancelAnimationFrame","startCurrent","initAnimations","fn","shift","dequeue","stop","source","initialTransformation","matrixify","clearQueue","clearCurrent","jumpToEnd","atEnd","reset","temp","atStart","isAbsPos","durDivSpd","speed","pause","last","play","progress","easeIt","wrapper","detail","off","on","_callStart","during","eased","afterAll","duringAll","method","args","ignoreTime","absPosInt","lastLoop","max","floor","Boolean","min","fire","fx","eachAt","self","apply","multiply","undo","extract","isEased","setTimeout","real","v","G","transform","num","Text","plot","leading","viewbox","ViewBox","update","Stop","Box","left","top","merge","xMin","Infinity","xMax","yMin","yMax","forEach","BBox","contains","Exception","topParent","Shape","clientLeft","clientTop","clientWidth","clientHeight","tbox","console","warn","rbox","RBox","getBoundingClientRect","addOffset","pageXOffset","pageYOffset","screenCTM","inverse","base","abcdef","px","py","skewX","atan2","transformedX","sqrt","transformedY","skewY","scaleX","scaleY","rotation","translate","scale","around","rotate","flip","skew","tan","createSVGMatrix","ctm","getCTM","rect","getScreenCTM","point","createSVGPoint","matrixTransform","attributes","nodeValue","image","Image","pattern","setAttributeNS","rebuild","Rotate","Scale","Skew","Translate","untransform","str","kv","toParent","pCtm","toDoc","Transformation","inversed","params","_undo","cssText","children","insertBefore","has","first","deep","removeChild","clear","hasChildNodes","lastChild","_defs","ungroup","depth","Defs","flatten","view","we","he","wm","hm","reg","offsetWidth","offsetHeight","zoom","event","listeners","handlerMap","listenerId","listener","binding","options","ev","_svgjsListenerId","removeEventListener","data","Event","dispatchEvent","CustomEvent","cancelable","gbox","trans","group","siblings","position","next","previous","forward","backward","front","back","before","Mask","targets","unmask","mask","maskWith","masker","ClipPath","unclip","clip","clipWith","clipper","gradient","fy","Pattern","patternUnits","getElementById","version","spof","Bare","words","text","createTextNode","Symbol","symbol","Use","file","use","Rect","Circle","circle","Ellipse","ellipse","Line","line","Polyline","Polygon","polygon","_array","morphArray","Path","load","img","_loaded","ratio","_error","src","loaded","error","_rebuild","_build","oy","nodeType","newLined","textContent","build","tspan","newLine","textPath","blankLineOffset","dy","plain","Tspan","dx","t","getComputedTextLength","TextPath","track","link","linkTo","Marker","ref","marker","sugar","prefix","extension","dmove","radius","getTotalLength","pointAt","getPointAtLength","font","members","elements","splice","set","remember","k","memory","forget","_memory","select","query","querySelectorAll","bubbles","createEvent","initCustomEvent","lastTime","vendors","callback","currTime","getTime","timeToCall","clearTimeout","_svg","newObj","default","list","item","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","refs","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","Error","removeStyleElement","idx","createStyleElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","styleSheet","replaceText","cssNode","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","DEBUG","newList","mayRemove","textStore","replacement"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"public/fonts/slkscr-webfont.eot\";\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(9)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!./game.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!./game.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n* svg.js - A lightweight library for manipulating and animating SVG.\n* @version 2.6.4\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Wed Feb 07 2018 22:59:25 GMT+0100 (Mitteleuropische Zeit)\n*/;\n(function(root, factory) {\r\n  /* istanbul ignore next */\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){\r\n      return factory(root, root.document)\r\n    }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n  } else {\r\n    root.SVG = factory(root, root.document)\r\n  }\r\n}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\r\n// The main wrapping element\r\nvar SVG = this.SVG = function(element) {\r\n  if (SVG.supported) {\r\n    element = new SVG.Doc(element)\r\n\r\n    if(!SVG.parser.draw)\r\n      SVG.prepare()\r\n\r\n    return element\r\n  }\r\n}\r\n\r\n// Default namespaces\r\nSVG.ns    = 'http://www.w3.org/2000/svg'\r\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\nSVG.xlink = 'http://www.w3.org/1999/xlink'\r\nSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\r\n// Svg support test\r\nSVG.supported = (function() {\r\n  return !! document.createElementNS &&\r\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n})()\r\n\r\n// Don't bother to continue if SVG is not supported\r\nif (!SVG.supported) return false\r\n\r\n// Element id sequence\r\nSVG.did  = 1000\r\n\r\n// Get next named element id\r\nSVG.eid = function(name) {\r\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n}\r\n\r\n// Method for element creation\r\nSVG.create = function(name) {\r\n  // create element\r\n  var element = document.createElementNS(this.ns, name)\r\n\r\n  // apply unique id\r\n  element.setAttribute('id', this.eid(name))\r\n\r\n  return element\r\n}\r\n\r\n// Method for extending objects\r\nSVG.extend = function() {\r\n  var modules, methods, key, i\r\n\r\n  // Get list of modules\r\n  modules = [].slice.call(arguments)\r\n\r\n  // Get object with extensions\r\n  methods = modules.pop()\r\n\r\n  for (i = modules.length - 1; i >= 0; i--)\r\n    if (modules[i])\r\n      for (key in methods)\r\n        modules[i].prototype[key] = methods[key]\r\n\r\n  // Make sure SVG.Set inherits any newly added methods\r\n  if (SVG.Set && SVG.Set.inherit)\r\n    SVG.Set.inherit()\r\n}\r\n\r\n// Invent new element\r\nSVG.invent = function(config) {\r\n  // Create element initializer\r\n  var initializer = typeof config.create == 'function' ?\r\n    config.create :\r\n    function() {\r\n      this.constructor.call(this, SVG.create(config.create))\r\n    }\r\n\r\n  // Inherit prototype\r\n  if (config.inherit)\r\n    initializer.prototype = new config.inherit\r\n\r\n  // Extend with methods\r\n  if (config.extend)\r\n    SVG.extend(initializer, config.extend)\r\n\r\n  // Attach construct method to parent\r\n  if (config.construct)\r\n    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\r\n  return initializer\r\n}\r\n\r\n// Adopt existing svg elements\r\nSVG.adopt = function(node) {\r\n  // check for presence of node\r\n  if (!node) return null\r\n\r\n  // make sure a node isn't already adopted\r\n  if (node.instance) return node.instance\r\n\r\n  // initialize variables\r\n  var element\r\n\r\n  // adopt with element-specific settings\r\n  if (node.nodeName == 'svg')\r\n    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n  else if (node.nodeName == 'linearGradient')\r\n    element = new SVG.Gradient('linear')\r\n  else if (node.nodeName == 'radialGradient')\r\n    element = new SVG.Gradient('radial')\r\n  else if (SVG[capitalize(node.nodeName)])\r\n    element = new SVG[capitalize(node.nodeName)]\r\n  else\r\n    element = new SVG.Element(node)\r\n\r\n  // ensure references\r\n  element.type  = node.nodeName\r\n  element.node  = node\r\n  node.instance = element\r\n\r\n  // SVG.Class specific preparations\r\n  if (element instanceof SVG.Doc)\r\n    element.namespace().defs()\r\n\r\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\r\n  return element\r\n}\r\n\r\n// Initialize parsing element\r\nSVG.prepare = function() {\r\n  // Select document body and create invisible svg element\r\n  var body = document.getElementsByTagName('body')[0]\r\n    , draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\r\n  // Create parser object\r\n  SVG.parser = {\r\n    body: body || document.documentElement\r\n  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node\r\n  , poly: draw.polyline().node\r\n  , path: draw.path().node\r\n  , native: SVG.create('svg')\r\n  }\r\n}\r\n\r\nSVG.parser = {\r\n  native: SVG.create('svg')\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n  if(!SVG.parser.draw)\r\n    SVG.prepare()\r\n}, false)\r\n\n// Storage for regular expressions\r\nSVG.regex = {\r\n  // Parse unit value\r\n  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\r\n  // Parse hex value\r\n, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\r\n  // Parse rgb value\r\n, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\r\n  // Parse reference id\r\n, reference:        /#([a-z0-9\\-_]+)/i\r\n\r\n  // splits a transformation chain\r\n, transforms:       /\\)\\s*,?\\s*/\r\n\r\n  // Whitespace\r\n, whitespace:       /\\s/g\r\n\r\n  // Test hex value\r\n, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\r\n  // Test rgb value\r\n, isRgb:            /^rgb\\(/\r\n\r\n  // Test css declaration\r\n, isCss:            /[^:]+:[^;]+;?/\r\n\r\n  // Test for blank string\r\n, isBlank:          /^(\\s+)?$/\r\n\r\n  // Test for numeric string\r\n, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\r\n  // Test for percent value\r\n, isPercent:        /^-?[\\d\\.]+%$/\r\n\r\n  // Test for image url\r\n, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\r\n  // split at whitespace and comma\r\n, delimiter:        /[\\s,]+/\r\n\r\n  // The following regex are used to parse the d attribute of a path\r\n\r\n  // Matches all hyphens which are not after an exponent\r\n, hyphen:           /([^e])\\-/gi\r\n\r\n  // Replaces and tests for all path letters\r\n, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\r\n  // yes we need this one, too\r\n, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\r\n  // matches 0.154.23.45\r\n, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\r\n  // matches .\r\n, dots:             /\\./g\r\n}\r\n\nSVG.utils = {\r\n  // Map function\r\n  map: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      result.push(block(array[i]))\r\n\r\n    return result\r\n  }\r\n\r\n  // Filter function\r\n, filter: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      if (block(array[i]))\r\n        result.push(array[i])\r\n\r\n    return result\r\n  }\r\n\r\n  // Degrees to radians\r\n, radians: function(d) {\r\n    return d % 360 * Math.PI / 180\r\n  }\r\n\r\n  // Radians to degrees\r\n, degrees: function(r) {\r\n    return r * 180 / Math.PI % 360\r\n  }\r\n\r\n, filterSVGElements: function(nodes) {\r\n    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n  }\r\n\r\n}\n\r\nSVG.defaults = {\r\n  // Default attribute values\r\n  attrs: {\r\n    // fill and stroke\r\n    'fill-opacity':     1\r\n  , 'stroke-opacity':   1\r\n  , 'stroke-width':     0\r\n  , 'stroke-linejoin':  'miter'\r\n  , 'stroke-linecap':   'butt'\r\n  , fill:               '#000000'\r\n  , stroke:             '#000000'\r\n  , opacity:            1\r\n    // position\r\n  , x:                  0\r\n  , y:                  0\r\n  , cx:                 0\r\n  , cy:                 0\r\n    // size\r\n  , width:              0\r\n  , height:             0\r\n    // radius\r\n  , r:                  0\r\n  , rx:                 0\r\n  , ry:                 0\r\n    // gradient\r\n  , offset:             0\r\n  , 'stop-opacity':     1\r\n  , 'stop-color':       '#000000'\r\n    // text\r\n  , 'font-size':        16\r\n  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n  , 'text-anchor':      'start'\r\n  }\r\n\r\n}\n// Module for color convertions\r\nSVG.Color = function(color) {\r\n  var match\r\n\r\n  // initialize defaults\r\n  this.r = 0\r\n  this.g = 0\r\n  this.b = 0\r\n\r\n  if(!color) return\r\n\r\n  // parse color\r\n  if (typeof color === 'string') {\r\n    if (SVG.regex.isRgb.test(color)) {\r\n      // get rgb values\r\n      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1])\r\n      this.g = parseInt(match[2])\r\n      this.b = parseInt(match[3])\r\n\r\n    } else if (SVG.regex.isHex.test(color)) {\r\n      // get hex values\r\n      match = SVG.regex.hex.exec(fullHex(color))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1], 16)\r\n      this.g = parseInt(match[2], 16)\r\n      this.b = parseInt(match[3], 16)\r\n\r\n    }\r\n\r\n  } else if (typeof color === 'object') {\r\n    this.r = color.r\r\n    this.g = color.g\r\n    this.b = color.b\r\n\r\n  }\r\n\r\n}\r\n\r\nSVG.extend(SVG.Color, {\r\n  // Default to hex conversion\r\n  toString: function() {\r\n    return this.toHex()\r\n  }\r\n  // Build hex value\r\n, toHex: function() {\r\n    return '#'\r\n      + compToHex(this.r)\r\n      + compToHex(this.g)\r\n      + compToHex(this.b)\r\n  }\r\n  // Build rgb value\r\n, toRgb: function() {\r\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n  }\r\n  // Calculate true brightness\r\n, brightness: function() {\r\n    return (this.r / 255 * 0.30)\r\n         + (this.g / 255 * 0.59)\r\n         + (this.b / 255 * 0.11)\r\n  }\r\n  // Make color morphable\r\n, morph: function(color) {\r\n    this.destination = new SVG.Color(color)\r\n\r\n    return this\r\n  }\r\n  // Get morphed color at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // normalise pos\r\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\r\n    // generate morphed color\r\n    return new SVG.Color({\r\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n    })\r\n  }\r\n\r\n})\r\n\r\n// Testers\r\n\r\n// Test if given value is a color string\r\nSVG.Color.test = function(color) {\r\n  color += ''\r\n  return SVG.regex.isHex.test(color)\r\n      || SVG.regex.isRgb.test(color)\r\n}\r\n\r\n// Test if given value is a rgb object\r\nSVG.Color.isRgb = function(color) {\r\n  return color && typeof color.r == 'number'\r\n               && typeof color.g == 'number'\r\n               && typeof color.b == 'number'\r\n}\r\n\r\n// Test if given value is a color\r\nSVG.Color.isColor = function(color) {\r\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n}\n// Module for array conversion\r\nSVG.Array = function(array, fallback) {\r\n  array = (array || []).valueOf()\r\n\r\n  // if array is empty and fallback is provided, use fallback\r\n  if (array.length == 0 && fallback)\r\n    array = fallback.valueOf()\r\n\r\n  // parse array\r\n  this.value = this.parse(array)\r\n}\r\n\r\nSVG.extend(SVG.Array, {\r\n  // Make array morphable\r\n  morph: function(array) {\r\n    this.destination = this.parse(array)\r\n\r\n    // normalize length of arrays\r\n    if (this.value.length != this.destination.length) {\r\n      var lastValue       = this.value[this.value.length - 1]\r\n        , lastDestination = this.destination[this.destination.length - 1]\r\n\r\n      while(this.value.length > this.destination.length)\r\n        this.destination.push(lastDestination)\r\n      while(this.value.length < this.destination.length)\r\n        this.value.push(lastValue)\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Clean up any duplicate points\r\n, settle: function() {\r\n    // find all unique values\r\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n      if (seen.indexOf(this.value[i]) == -1)\r\n        seen.push(this.value[i])\r\n\r\n    // set new value\r\n    return this.value = seen\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed array\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\r\n    return new SVG.Array(array)\r\n  }\r\n  // Convert array to string\r\n, toString: function() {\r\n    return this.value.join(' ')\r\n  }\r\n  // Real value\r\n, valueOf: function() {\r\n    return this.value\r\n  }\r\n  // Parse whitespace separated string\r\n, parse: function(array) {\r\n    array = array.valueOf()\r\n\r\n    // if already is an array, no need to parse it\r\n    if (Array.isArray(array)) return array\r\n\r\n    return this.split(array)\r\n  }\r\n  // Strip unnecessary whitespace\r\n, split: function(string) {\r\n    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n  }\r\n  // Reverse array\r\n, reverse: function() {\r\n    this.value.reverse()\r\n\r\n    return this\r\n  }\r\n, clone: function() {\r\n    var clone = new this.constructor()\r\n    clone.value = array_clone(this.value)\r\n    return clone\r\n  }\r\n})\n// Poly points array\r\nSVG.PointArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [[0,0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PointArray.prototype = new SVG.Array\r\nSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\r\nSVG.extend(SVG.PointArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    // convert to a poly point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i].join(','))\r\n\r\n    return array.join(' ')\r\n  }\r\n  // Convert array to line object\r\n, toLine: function() {\r\n    return {\r\n      x1: this.value[0][0]\r\n    , y1: this.value[0][1]\r\n    , x2: this.value[1][0]\r\n    , y2: this.value[1][1]\r\n    }\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push([\r\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n      ])\r\n\r\n    return new SVG.PointArray(array)\r\n  }\r\n  // Parse point string and flat array\r\n, parse: function(array) {\r\n    var points = []\r\n\r\n    array = array.valueOf()\r\n\r\n    // if it is an array\r\n    if (Array.isArray(array)) {\r\n      // and it is not flat, there is no need to parse it\r\n      if(Array.isArray(array[0])) {\r\n        return array\r\n      }\r\n    } else { // Else, it is considered as a string\r\n      // parse points\r\n      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n    }\r\n\r\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n    if (array.length % 2 !== 0) array.pop()\r\n\r\n    // wrap points in two-tuples and parse points as floats\r\n    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n      points.push([ array[i], array[i+1] ])\r\n\r\n    return points\r\n  }\r\n  // Move point string\r\n, move: function(x, y) {\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    // move every point\r\n    if (!isNaN(x) && !isNaN(y))\r\n      for (var i = this.value.length - 1; i >= 0; i--)\r\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\r\n    return this\r\n  }\r\n  // Resize poly string\r\n, size: function(width, height) {\r\n    var i, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get bounding box of points\r\n, bbox: function() {\r\n    SVG.parser.poly.setAttribute('points', this.toString())\r\n\r\n    return SVG.parser.poly.getBBox()\r\n  }\r\n})\r\n\nvar pathHandlers = {\r\n  M: function(c, p, p0) {\r\n    p.x = p0.x = c[0]\r\n    p.y = p0.y = c[1]\r\n\r\n    return ['M', p.x, p.y]\r\n  },\r\n  L: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['L', c[0], c[1]]\r\n  },\r\n  H: function(c, p) {\r\n    p.x = c[0]\r\n    return ['H', c[0]]\r\n  },\r\n  V: function(c, p) {\r\n    p.y = c[0]\r\n    return ['V', c[0]]\r\n  },\r\n  C: function(c, p) {\r\n    p.x = c[4]\r\n    p.y = c[5]\r\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\r\n  },\r\n  S: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['S', c[0], c[1], c[2], c[3]]\r\n  },\r\n  Q: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['Q', c[0], c[1], c[2], c[3]]\r\n  },\r\n  T: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['T', c[0], c[1]]\r\n  },\r\n  Z: function(c, p, p0) {\r\n    p.x = p0.x\r\n    p.y = p0.y\r\n    return ['Z']\r\n  },\r\n  A: function(c, p) {\r\n    p.x = c[5]\r\n    p.y = c[6]\r\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\r\n  }\r\n}\r\n\r\nvar mlhvqtcsa = 'mlhvqtcsaz'.split('')\r\n\r\nfor(var i = 0, il = mlhvqtcsa.length; i < il; ++i){\r\n  pathHandlers[mlhvqtcsa[i]] = (function(i){\r\n    return function(c, p, p0) {\r\n      if(i == 'H') c[0] = c[0] + p.x\r\n      else if(i == 'V') c[0] = c[0] + p.y\r\n      else if(i == 'A'){\r\n        c[5] = c[5] + p.x,\r\n        c[6] = c[6] + p.y\r\n      }\r\n      else\r\n        for(var j = 0, jl = c.length; j < jl; ++j) {\r\n          c[j] = c[j] + (j%2 ? p.y : p.x)\r\n        }\r\n\r\n      return pathHandlers[i](c, p, p0)\r\n    }\r\n  })(mlhvqtcsa[i].toUpperCase())\r\n}\r\n\r\n// Path points array\r\nSVG.PathArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PathArray.prototype = new SVG.Array\r\nSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    return arrayToString(this.value)\r\n  }\r\n  // Move path string\r\n, move: function(x, y) {\r\n    // get bounding box of current situation\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    if (!isNaN(x) && !isNaN(y)) {\r\n      // move every point\r\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n        l = this.value[i][0]\r\n\r\n        if (l == 'M' || l == 'L' || l == 'T')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n\r\n        } else if (l == 'H')  {\r\n          this.value[i][1] += x\r\n\r\n        } else if (l == 'V')  {\r\n          this.value[i][1] += y\r\n\r\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n          this.value[i][3] += x\r\n          this.value[i][4] += y\r\n\r\n          if (l == 'C')  {\r\n            this.value[i][5] += x\r\n            this.value[i][6] += y\r\n          }\r\n\r\n        } else if (l == 'A')  {\r\n          this.value[i][6] += x\r\n          this.value[i][7] += y\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Resize path string\r\n, size: function(width, height) {\r\n    // get bounding box of current situation\r\n    var i, l, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      l = this.value[i][0]\r\n\r\n      if (l == 'M' || l == 'L' || l == 'T')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'H')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\r\n      } else if (l == 'V')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\r\n        if (l == 'C')  {\r\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n        }\r\n\r\n      } else if (l == 'A')  {\r\n        // resize radii\r\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\r\n        // move position values\r\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n      }\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Test if the passed path array use the same path data commands as this path array\r\n, equalCommands: function(pathArray) {\r\n    var i, il, equalCommands\r\n\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    equalCommands = this.value.length === pathArray.value.length\r\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n    }\r\n\r\n    return equalCommands\r\n  }\r\n  // Make path array morphable\r\n, morph: function(pathArray) {\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    if(this.equalCommands(pathArray)) {\r\n      this.destination = pathArray\r\n    } else {\r\n      this.destination = null\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get morphed path array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    var sourceArray = this.value\r\n      , destinationArray = this.destination.value\r\n      , array = [], pathArray = new SVG.PathArray()\r\n      , i, il, j, jl\r\n\r\n    // Animate has specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n      array[i] = [sourceArray[i][0]]\r\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n      }\r\n      // For the two flags of the elliptical arc command, the SVG spec say:\r\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n      // Elliptical arc command as an array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      if(array[i][0] === 'A') {\r\n        array[i][4] = +(array[i][4] != 0)\r\n        array[i][5] = +(array[i][5] != 0)\r\n      }\r\n    }\r\n\r\n    // Directly modify the value of a path array, this is done this way for performance\r\n    pathArray.value = array\r\n    return pathArray\r\n  }\r\n  // Absolutize and parse path to array\r\n, parse: function(array) {\r\n    // if it's already a patharray, no need to parse it\r\n    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\r\n    // prepare for parsing\r\n    var i, x0, y0, s, seg, arr\r\n      , x = 0\r\n      , y = 0\r\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7, 'Z':0 }\r\n\r\n    if(typeof array == 'string'){\r\n\r\n      array = array\r\n        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n        .trim()                                 // trim\r\n        .split(SVG.regex.delimiter)   // split into array\r\n\r\n    }else{\r\n      array = array.reduce(function(prev, curr){\r\n        return [].concat.call(prev, curr)\r\n      }, [])\r\n    }\r\n\r\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n    var arr = []\r\n      , p = new SVG.Point()\r\n      , p0 = new SVG.Point()\r\n      , index = 0\r\n      , len = array.length\r\n\r\n    do{\r\n      // Test if we have a path letter\r\n      if(SVG.regex.isPathLetter.test(array[index])){\r\n        s = array[index]\r\n        ++index\r\n      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n      }else if(s == 'M'){\r\n        s = 'L'\r\n      }else if(s == 'm'){\r\n        s = 'l'\r\n      }\r\n\r\n      arr.push(pathHandlers[s].call(null,\r\n          array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),\r\n          p, p0\r\n        )\r\n      )\r\n\r\n    }while(len > index)\r\n\r\n    return arr\r\n\r\n  }\r\n  // Get bounding box of path\r\n, bbox: function() {\r\n    SVG.parser.path.setAttribute('d', this.toString())\r\n\r\n    return SVG.parser.path.getBBox()\r\n  }\r\n\r\n})\r\n\n// Module for unit convertions\r\nSVG.Number = SVG.invent({\r\n  // Initialize\r\n  create: function(value, unit) {\r\n    // initialize defaults\r\n    this.value = 0\r\n    this.unit  = unit || ''\r\n\r\n    // parse value\r\n    if (typeof value === 'number') {\r\n      // ensure a valid numeric value\r\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\r\n    } else if (typeof value === 'string') {\r\n      unit = value.match(SVG.regex.numberAndUnit)\r\n\r\n      if (unit) {\r\n        // make value numeric\r\n        this.value = parseFloat(unit[1])\r\n\r\n        // normalize\r\n        if (unit[5] == '%')\r\n          this.value /= 100\r\n        else if (unit[5] == 's')\r\n          this.value *= 1000\r\n\r\n        // store unit\r\n        this.unit = unit[5]\r\n      }\r\n\r\n    } else {\r\n      if (value instanceof SVG.Number) {\r\n        this.value = value.valueOf()\r\n        this.unit  = value.unit\r\n      }\r\n    }\r\n\r\n  }\r\n  // Add methods\r\n, extend: {\r\n    // Stringalize\r\n    toString: function() {\r\n      return (\r\n        this.unit == '%' ?\r\n          ~~(this.value * 1e8) / 1e6:\r\n        this.unit == 's' ?\r\n          this.value / 1e3 :\r\n          this.value\r\n      ) + this.unit\r\n    }\r\n  , toJSON: function() {\r\n      return this.toString()\r\n    }\r\n  , // Convert to primitive\r\n    valueOf: function() {\r\n      return this.value\r\n    }\r\n    // Add number\r\n  , plus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this + number, this.unit || number.unit)\r\n    }\r\n    // Subtract number\r\n  , minus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this - number, this.unit || number.unit)\r\n    }\r\n    // Multiply number\r\n  , times: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this * number, this.unit || number.unit)\r\n    }\r\n    // Divide number\r\n  , divide: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this / number, this.unit || number.unit)\r\n    }\r\n    // Convert to different unit\r\n  , to: function(unit) {\r\n      var number = new SVG.Number(this)\r\n\r\n      if (typeof unit === 'string')\r\n        number.unit = unit\r\n\r\n      return number\r\n    }\r\n    // Make number morphable\r\n  , morph: function(number) {\r\n      this.destination = new SVG.Number(number)\r\n\r\n      if(number.relative) {\r\n        this.destination.value += this.value\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Get morphed number at given position\r\n  , at: function(pos) {\r\n      // Make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // Generate new morphed number\r\n      return new SVG.Number(this.destination)\r\n          .minus(this)\r\n          .times(pos)\r\n          .plus(this)\r\n    }\r\n\r\n  }\r\n})\r\n\n\r\nSVG.Element = SVG.invent({\r\n  // Initialize node\r\n  create: function(node) {\r\n    // make stroke value accessible dynamically\r\n    this._stroke = SVG.defaults.attrs.stroke\r\n    this._event = null\r\n\r\n    // initialize data object\r\n    this.dom = {}\r\n\r\n    // create circular reference\r\n    if (this.node = node) {\r\n      this.type = node.nodeName\r\n      this.node.instance = this\r\n\r\n      // store current attribute value\r\n      this._stroke = node.getAttribute('stroke') || this._stroke\r\n    }\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return this.attr('y', y)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n    }\r\n    // Move element to given x and y values\r\n  , move: function(x, y) {\r\n      return this.x(x).y(y)\r\n    }\r\n    // Move element by its center\r\n  , center: function(x, y) {\r\n      return this.cx(x).cy(y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return this.attr('width', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('height', height)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .width(new SVG.Number(p.width))\r\n        .height(new SVG.Number(p.height))\r\n    }\r\n    // Clone element\r\n  , clone: function(parent, withData) {\r\n      // write dom data to the dom so the clone can pickup the data\r\n      this.writeDataToDom()\r\n\r\n      // clone element and assign new id\r\n      var clone = assignNewId(this.node.cloneNode(true))\r\n\r\n      // insert the clone in the given parent or after myself\r\n      if(parent) parent.add(clone)\r\n      else this.after(clone)\r\n\r\n      return clone\r\n    }\r\n    // Remove element\r\n  , remove: function() {\r\n      if (this.parent())\r\n        this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n    // Replace element\r\n  , replace: function(element) {\r\n      this.after(element).remove()\r\n\r\n      return element\r\n    }\r\n    // Add element to given container and return self\r\n  , addTo: function(parent) {\r\n      return parent.put(this)\r\n    }\r\n    // Add element to given container and return container\r\n  , putIn: function(parent) {\r\n      return parent.add(this)\r\n    }\r\n    // Get / set id\r\n  , id: function(id) {\r\n      return this.attr('id', id)\r\n    }\r\n    // Checks whether the given point inside the bounding box of the element\r\n  , inside: function(x, y) {\r\n      var box = this.bbox()\r\n\r\n      return x > box.x\r\n          && y > box.y\r\n          && x < box.x + box.width\r\n          && y < box.y + box.height\r\n    }\r\n    // Show element\r\n  , show: function() {\r\n      return this.style('display', '')\r\n    }\r\n    // Hide element\r\n  , hide: function() {\r\n      return this.style('display', 'none')\r\n    }\r\n    // Is element visible?\r\n  , visible: function() {\r\n      return this.style('display') != 'none'\r\n    }\r\n    // Return id on string conversion\r\n  , toString: function() {\r\n      return this.attr('id')\r\n    }\r\n    // Return array of classes on the node\r\n  , classes: function() {\r\n      var attr = this.attr('class')\r\n\r\n      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n    }\r\n    // Return true if class exists on the node, false otherwise\r\n  , hasClass: function(name) {\r\n      return this.classes().indexOf(name) != -1\r\n    }\r\n    // Add class to the node\r\n  , addClass: function(name) {\r\n      if (!this.hasClass(name)) {\r\n        var array = this.classes()\r\n        array.push(name)\r\n        this.attr('class', array.join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove class from the node\r\n  , removeClass: function(name) {\r\n      if (this.hasClass(name)) {\r\n        this.attr('class', this.classes().filter(function(c) {\r\n          return c != name\r\n        }).join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Toggle the presence of a class on the node\r\n  , toggleClass: function(name) {\r\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n    }\r\n    // Get referenced element form attribute value\r\n  , reference: function(attr) {\r\n      return SVG.get(this.attr(attr))\r\n    }\r\n    // Returns the parent element instance\r\n  , parent: function(type) {\r\n      var parent = this\r\n\r\n      // check for parent\r\n      if(!parent.node.parentNode) return null\r\n\r\n      // get parent element\r\n      parent = SVG.adopt(parent.node.parentNode)\r\n\r\n      if(!type) return parent\r\n\r\n      // loop trough ancestors if type is given\r\n      while(parent && parent.node instanceof window.SVGElement){\r\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n        if(parent.node.parentNode.nodeName == '#document') return null // #720\r\n        parent = SVG.adopt(parent.node.parentNode)\r\n      }\r\n    }\r\n    // Get parent document\r\n  , doc: function() {\r\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n    }\r\n    // return array of all ancestors of given type up to the root svg\r\n  , parents: function(type) {\r\n      var parents = [], parent = this\r\n\r\n      do{\r\n        parent = parent.parent(type)\r\n        if(!parent || !parent.node) break\r\n\r\n        parents.push(parent)\r\n      } while(parent.parent)\r\n\r\n      return parents\r\n    }\r\n    // matches the element vs a css selector\r\n  , matches: function(selector){\r\n      return matches(this.node, selector)\r\n    }\r\n    // Returns the svg node to call native svg methods on it\r\n  , native: function() {\r\n      return this.node\r\n    }\r\n    // Import raw svg\r\n  , svg: function(svg) {\r\n      // create temporary holder\r\n      var well = document.createElement('svg')\r\n\r\n      // act as a setter if svg is given\r\n      if (svg && this instanceof SVG.Parent) {\r\n        // dump raw svg\r\n        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\r\n        // transplant nodes\r\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n          this.node.appendChild(well.firstChild.firstChild)\r\n\r\n      // otherwise act as a getter\r\n      } else {\r\n        // create a wrapping svg element in case of partial content\r\n        well.appendChild(svg = document.createElement('svg'))\r\n\r\n        // write svgjs data to the dom\r\n        this.writeDataToDom()\r\n\r\n        // insert a copy of this node\r\n        svg.appendChild(this.node.cloneNode(true))\r\n\r\n        // return target element\r\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n      }\r\n\r\n      return this\r\n    }\r\n  // write svgjs data to the dom\r\n  , writeDataToDom: function() {\r\n\r\n      // dump variables recursively\r\n      if(this.each || this.lines){\r\n        var fn = this.each ? this : this.lines();\r\n        fn.each(function(){\r\n          this.writeDataToDom()\r\n        })\r\n      }\r\n\r\n      // remove previously set data\r\n      this.node.removeAttribute('svgjs:data')\r\n\r\n      if(Object.keys(this.dom).length)\r\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\r\n      return this\r\n    }\r\n  // set given data to the elements data property\r\n  , setData: function(o){\r\n      this.dom = o\r\n      return this\r\n    }\r\n  , is: function(obj){\r\n      return is(this, obj)\r\n    }\r\n  }\r\n})\r\n\nSVG.easing = {\r\n  '-': function(pos){return pos}\r\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n}\r\n\r\nSVG.morph = function(pos){\r\n  return function(from, to) {\r\n    return new SVG.MorphObj(from, to).at(pos)\r\n  }\r\n}\r\n\r\nSVG.Situation = SVG.invent({\r\n\r\n  create: function(o){\r\n    this.init = false\r\n    this.reversed = false\r\n    this.reversing = false\r\n\r\n    this.duration = new SVG.Number(o.duration).valueOf()\r\n    this.delay = new SVG.Number(o.delay).valueOf()\r\n\r\n    this.start = +new Date() + this.delay\r\n    this.finish = this.start + this.duration\r\n    this.ease = o.ease\r\n\r\n    // this.loop is incremented from 0 to this.loops\r\n    // it is also incremented when in an infinite loop (when this.loops is true)\r\n    this.loop = 0\r\n    this.loops = false\r\n\r\n    this.animations = {\r\n      // functionToCall: [list of morphable objects]\r\n      // e.g. move: [SVG.Number, SVG.Number]\r\n    }\r\n\r\n    this.attrs = {\r\n      // holds all attributes which are not represented from a function svg.js provides\r\n      // e.g. someAttr: SVG.Number\r\n    }\r\n\r\n    this.styles = {\r\n      // holds all styles which should be animated\r\n      // e.g. fill-color: SVG.Color\r\n    }\r\n\r\n    this.transforms = [\r\n      // holds all transformations as transformation objects\r\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n    ]\r\n\r\n    this.once = {\r\n      // functions to fire at a specific position\r\n      // e.g. \"0.5\": function foo(){}\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\n\r\nSVG.FX = SVG.invent({\r\n\r\n  create: function(element) {\r\n    this._target = element\r\n    this.situations = []\r\n    this.active = false\r\n    this.situation = null\r\n    this.paused = false\r\n    this.lastPos = 0\r\n    this.pos = 0\r\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n    this.absPos = 0\r\n    this._speed = 1\r\n  }\r\n\r\n, extend: {\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n     * @param ease function || string Function which should be used for easing or easing keyword\r\n     * @param delay Number indicating the delay before the animation starts\r\n     * @return target || this\r\n     */\r\n    animate: function(o, ease, delay){\r\n\r\n      if(typeof o == 'object'){\r\n        ease = o.ease\r\n        delay = o.delay\r\n        o = o.duration\r\n      }\r\n\r\n      var situation = new SVG.Situation({\r\n        duration: o || 1000,\r\n        delay: delay || 0,\r\n        ease: SVG.easing[ease || '-'] || ease\r\n      })\r\n\r\n      this.queue(situation)\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * sets a delay before the next element of the queue is called\r\n     * @param delay Duration of delay in milliseconds\r\n     * @return this.target()\r\n     */\r\n  , delay: function(delay){\r\n      // The delay is performed by an empty situation with its duration\r\n      // attribute set to the duration of the delay\r\n      var situation = new SVG.Situation({\r\n        duration: delay,\r\n        delay: 0,\r\n        ease: SVG.easing['-']\r\n      })\r\n\r\n      return this.queue(situation)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param null || target SVG.Element which should be set as new target\r\n     * @return target || this\r\n     */\r\n  , target: function(target){\r\n      if(target && target instanceof SVG.Element){\r\n        this._target = target\r\n        return this\r\n      }\r\n\r\n      return this._target\r\n    }\r\n\r\n    // returns the absolute position at a given time\r\n  , timeToAbsPos: function(timestamp){\r\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n    }\r\n\r\n    // returns the timestamp from a given absolute positon\r\n  , absPosToTime: function(absPos){\r\n      return this.situation.duration/this._speed * absPos + this.situation.start\r\n    }\r\n\r\n    // starts the animationloop\r\n  , startAnimFrame: function(){\r\n      this.stopAnimFrame()\r\n      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n    }\r\n\r\n    // cancels the animationframe\r\n  , stopAnimFrame: function(){\r\n      window.cancelAnimationFrame(this.animationFrame)\r\n    }\r\n\r\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n  , start: function(){\r\n      // dont start if already started\r\n      if(!this.active && this.situation){\r\n        this.active = true\r\n        this.startCurrent()\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // start the current situation\r\n  , startCurrent: function(){\r\n      this.situation.start = +new Date + this.situation.delay/this._speed\r\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n      return this.initAnimations().step()\r\n    }\r\n\r\n    /**\r\n     * adds a function / Situation to the animation queue\r\n     * @param fn function / situation to add\r\n     * @return this\r\n     */\r\n  , queue: function(fn){\r\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n        this.situations.push(fn)\r\n\r\n      if(!this.situation) this.situation = this.situations.shift()\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * pulls next element from the queue and execute it\r\n     * @return this\r\n     */\r\n  , dequeue: function(){\r\n      // stop current animation\r\n      this.stop()\r\n\r\n      // get next animation from queue\r\n      this.situation = this.situations.shift()\r\n\r\n      if(this.situation){\r\n        if(this.situation instanceof SVG.Situation) {\r\n          this.start()\r\n        } else {\r\n          // If it is not a SVG.Situation, then it is a function, we execute it\r\n          this.situation.call(this)\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // updates all animations to the current state of the element\r\n    // this is important when one property could be changed from another property\r\n  , initAnimations: function() {\r\n      var i, j, source\r\n      var s = this.situation\r\n\r\n      if(s.init) return this\r\n\r\n      for(i in s.animations){\r\n        source = this.target()[i]()\r\n\r\n        if(!Array.isArray(source)) {\r\n          source = [source]\r\n        }\r\n\r\n        if(!Array.isArray(s.animations[i])) {\r\n          s.animations[i] = [s.animations[i]]\r\n        }\r\n\r\n        //if(s.animations[i].length > source.length) {\r\n        //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))\r\n        //}\r\n\r\n        for(j = source.length; j--;) {\r\n          // The condition is because some methods return a normal number instead\r\n          // of a SVG.Number\r\n          if(s.animations[i][j] instanceof SVG.Number)\r\n            source[j] = new SVG.Number(source[j])\r\n\r\n          s.animations[i][j] = source[j].morph(s.animations[i][j])\r\n        }\r\n      }\r\n\r\n      for(i in s.attrs){\r\n        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n      }\r\n\r\n      for(i in s.styles){\r\n        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n      }\r\n\r\n      s.initialTransformation = this.target().matrixify()\r\n\r\n      s.init = true\r\n      return this\r\n    }\r\n  , clearQueue: function(){\r\n      this.situations = []\r\n      return this\r\n    }\r\n  , clearCurrent: function(){\r\n      this.situation = null\r\n      return this\r\n    }\r\n    /** stops the animation immediately\r\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n     * @return this\r\n     */\r\n  , stop: function(jumpToEnd, clearQueue){\r\n      var active = this.active\r\n      this.active = false\r\n\r\n      if(clearQueue){\r\n        this.clearQueue()\r\n      }\r\n\r\n      if(jumpToEnd && this.situation){\r\n        // initialize the situation if it was not\r\n        !active && this.startCurrent()\r\n        this.atEnd()\r\n      }\r\n\r\n      this.stopAnimFrame()\r\n\r\n      return this.clearCurrent()\r\n    }\r\n\r\n    /** resets the element to the state where the current element has started\r\n     * @return this\r\n     */\r\n  , reset: function(){\r\n      if(this.situation){\r\n        var temp = this.situation\r\n        this.stop()\r\n        this.situation = temp\r\n        this.atStart()\r\n      }\r\n      return this\r\n    }\r\n\r\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n  , finish: function(){\r\n\r\n      this.stop(true, false)\r\n\r\n      while(this.dequeue().situation && this.stop(true, false));\r\n\r\n      this.clearQueue().clearCurrent()\r\n\r\n      return this\r\n    }\r\n\r\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n  , atStart: function() {\r\n      return this.at(0, true)\r\n    }\r\n\r\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n  , atEnd: function() {\r\n      if (this.situation.loops === true) {\r\n        // If in a infinite loop, we end the current iteration\r\n        this.situation.loops = this.situation.loop + 1\r\n      }\r\n\r\n      if(typeof this.situation.loops == 'number') {\r\n        // If performing a finite number of loops, we go after all the loops\r\n        return this.at(this.situation.loops, true)\r\n      } else {\r\n        // If no loops, we just go at the end\r\n        return this.at(1, true)\r\n      }\r\n    }\r\n\r\n    // set the internal animation pointer to the specified position and updates the visualisation\r\n    // if isAbsPos is true, pos is treated as an absolute position\r\n  , at: function(pos, isAbsPos){\r\n      var durDivSpd = this.situation.duration/this._speed\r\n\r\n      this.absPos = pos\r\n      // If pos is not an absolute position, we convert it into one\r\n      if (!isAbsPos) {\r\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n        this.absPos += this.situation.loop\r\n      }\r\n\r\n      this.situation.start = +new Date - this.absPos * durDivSpd\r\n      this.situation.finish = this.situation.start + durDivSpd\r\n\r\n      return this.step(true)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the speed of the animations\r\n     * @param speed null || Number The new speed of the animations\r\n     * @return Number || this\r\n     */\r\n  , speed: function(speed){\r\n      if (speed === 0) return this.pause()\r\n\r\n      if (speed) {\r\n        this._speed = speed\r\n        // We use an absolute position here so that speed can affect the delay before the animation\r\n        return this.at(this.absPos, true)\r\n      } else return this._speed\r\n    }\r\n\r\n    // Make loopable\r\n  , loop: function(times, reverse) {\r\n      var c = this.last()\r\n\r\n      // store total loops\r\n      c.loops = (times != null) ? times : true\r\n      c.loop = 0\r\n\r\n      if(reverse) c.reversing = true\r\n      return this\r\n    }\r\n\r\n    // pauses the animation\r\n  , pause: function(){\r\n      this.paused = true\r\n      this.stopAnimFrame()\r\n\r\n      return this\r\n    }\r\n\r\n    // unpause the animation\r\n  , play: function(){\r\n      if(!this.paused) return this\r\n      this.paused = false\r\n      // We use an absolute position here so that the delay before the animation can be paused\r\n      return this.at(this.absPos, true)\r\n    }\r\n\r\n    /**\r\n     * toggle or set the direction of the animation\r\n     * true sets direction to backwards while false sets it to forwards\r\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n     * @return this\r\n     */\r\n  , reverse: function(reversed){\r\n      var c = this.last()\r\n\r\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n      else c.reversed = reversed\r\n\r\n      return this\r\n    }\r\n\r\n\r\n    /**\r\n     * returns a float from 0-1 indicating the progress of the current animation\r\n     * @param eased Boolean indicating whether the returned position should be eased or not\r\n     * @return number\r\n     */\r\n  , progress: function(easeIt){\r\n      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n    }\r\n\r\n    /**\r\n     * adds a callback function which is called when the current animation is finished\r\n     * @param fn Function which should be executed as callback\r\n     * @return number\r\n     */\r\n  , after: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function wrapper(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, c)\r\n              this.off('finished.fx', wrapper) // prevent memory leak\r\n            }\r\n          }\r\n\r\n      this.target().on('finished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // adds a callback which is called whenever one animation step is performed\r\n  , during: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n            }\r\n          }\r\n\r\n      // see above\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.after(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls after ALL animations in the queue are finished\r\n  , afterAll: function(fn){\r\n      var wrapper = function wrapper(e){\r\n            fn.call(this)\r\n            this.off('allfinished.fx', wrapper)\r\n          }\r\n\r\n      // see above\r\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls on every animation step for all animations\r\n  , duringAll: function(fn){\r\n      var wrapper = function(e){\r\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n          }\r\n\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.afterAll(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n  , last: function(){\r\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n    }\r\n\r\n    // adds one property to the animations\r\n  , add: function(method, args, type){\r\n      this.last()[type || 'animations'][method] = args\r\n      return this._callStart()\r\n    }\r\n\r\n    /** perform one step of the animation\r\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n     *  @return this\r\n     */\r\n  , step: function(ignoreTime){\r\n\r\n      // convert current time to an absolute position\r\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\r\n      // This part convert an absolute position to a position\r\n      if(this.situation.loops !== false) {\r\n        var absPos, absPosInt, lastLoop\r\n\r\n        // If the absolute position is below 0, we just treat it as if it was 0\r\n        absPos = Math.max(this.absPos, 0)\r\n        absPosInt = Math.floor(absPos)\r\n\r\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n          this.pos = absPos - absPosInt\r\n          lastLoop = this.situation.loop\r\n          this.situation.loop = absPosInt\r\n        } else {\r\n          this.absPos = this.situation.loops\r\n          this.pos = 1\r\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n          lastLoop = this.situation.loop - 1\r\n          this.situation.loop = this.situation.loops\r\n        }\r\n\r\n        if(this.situation.reversing) {\r\n          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n        }\r\n\r\n      } else {\r\n        // If there are no loop, the absolute position must not be above 1\r\n        this.absPos = Math.min(this.absPos, 1)\r\n        this.pos = this.absPos\r\n      }\r\n\r\n      // while the absolute position can be below 0, the position must not be below 0\r\n      if(this.pos < 0) this.pos = 0\r\n\r\n      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\r\n\r\n      // apply easing\r\n      var eased = this.situation.ease(this.pos)\r\n\r\n      // call once-callbacks\r\n      for(var i in this.situation.once){\r\n        if(i > this.lastPos && i <= eased){\r\n          this.situation.once[i].call(this.target(), this.pos, eased)\r\n          delete this.situation.once[i]\r\n        }\r\n      }\r\n\r\n      // fire during callback with position, eased position and current situation as parameter\r\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\r\n      // the user may call stop or finish in the during callback\r\n      // so make sure that we still have a valid situation\r\n      if(!this.situation){\r\n        return this\r\n      }\r\n\r\n      // apply the actual animation to every property\r\n      this.eachAt()\r\n\r\n      // do final code when situation is finished\r\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\r\n        // stop animation callback\r\n        this.stopAnimFrame()\r\n\r\n        // fire finished callback with current situation as parameter\r\n        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\r\n        if(!this.situations.length){\r\n          this.target().fire('allfinished')\r\n\r\n          // Recheck the length since the user may call animate in the afterAll callback\r\n          if(!this.situations.length){\r\n            this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n            this.active = false\r\n          }\r\n        }\r\n\r\n        // start next animation\r\n        if(this.active) this.dequeue()\r\n        else this.clearCurrent()\r\n\r\n      }else if(!this.paused && this.active){\r\n        // we continue animating when we are not at the end\r\n        this.startAnimFrame()\r\n      }\r\n\r\n      // save last eased position for once callback triggering\r\n      this.lastPos = eased\r\n      return this\r\n\r\n    }\r\n\r\n    // calculates the step for every property and calls block with it\r\n  , eachAt: function(){\r\n      var i, len, at, self = this, target = this.target(), s = this.situation\r\n\r\n      // apply animations which can be called trough a method\r\n      for(i in s.animations){\r\n\r\n        at = [].concat(s.animations[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target[i].apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with attr()\r\n      for(i in s.attrs){\r\n\r\n        at = [i].concat(s.attrs[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.attr.apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with style()\r\n      for(i in s.styles){\r\n\r\n        at = [i].concat(s.styles[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.style.apply(target, at)\r\n\r\n      }\r\n\r\n      // animate initialTransformation which has to be chained\r\n      if(s.transforms.length){\r\n\r\n        // get initial initialTransformation\r\n        at = s.initialTransformation\r\n        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\r\n          // get next transformation in chain\r\n          var a = s.transforms[i]\r\n\r\n          // multiply matrix directly\r\n          if(a instanceof SVG.Matrix){\r\n\r\n            if(a.relative){\r\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n            }else{\r\n              at = at.morph(a).at(s.ease(this.pos))\r\n            }\r\n            continue\r\n          }\r\n\r\n          // when transformation is absolute we have to reset the needed transformation first\r\n          if(!a.relative)\r\n            a.undo(at.extract())\r\n\r\n          // and reapply it after\r\n          at = at.multiply(a.at(s.ease(this.pos)))\r\n\r\n        }\r\n\r\n        // set new matrix on element\r\n        target.matrix(at)\r\n      }\r\n\r\n      return this\r\n\r\n    }\r\n\r\n\r\n    // adds an once-callback which is called at a specific position and never again\r\n  , once: function(pos, fn, isEased){\r\n      var c = this.last()\r\n      if(!isEased) pos = c.ease(pos)\r\n\r\n      c.once[pos] = fn\r\n\r\n      return this\r\n    }\r\n\r\n  , _callStart: function() {\r\n      setTimeout(function(){this.start()}.bind(this), 0)\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n, parent: SVG.Element\r\n\r\n  // Add method to parent elements\r\n, construct: {\r\n    // Get fx module or create a new one, then animate with given duration and ease\r\n    animate: function(o, ease, delay) {\r\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n    }\r\n  , delay: function(delay){\r\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n    }\r\n  , stop: function(jumpToEnd, clearQueue) {\r\n      if (this.fx)\r\n        this.fx.stop(jumpToEnd, clearQueue)\r\n\r\n      return this\r\n    }\r\n  , finish: function() {\r\n      if (this.fx)\r\n        this.fx.finish()\r\n\r\n      return this\r\n    }\r\n    // Pause current animation\r\n  , pause: function() {\r\n      if (this.fx)\r\n        this.fx.pause()\r\n\r\n      return this\r\n    }\r\n    // Play paused current animation\r\n  , play: function() {\r\n      if (this.fx)\r\n        this.fx.play()\r\n\r\n      return this\r\n    }\r\n    // Set/Get the speed of the animations\r\n  , speed: function(speed) {\r\n      if (this.fx)\r\n        if (speed == null)\r\n          return this.fx.speed()\r\n        else\r\n          this.fx.speed(speed)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\n// MorphObj is used whenever no morphable object is given\r\nSVG.MorphObj = SVG.invent({\r\n\r\n  create: function(from, to){\r\n    // prepare color for morphing\r\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n    // prepare value list for morphing\r\n    if(SVG.regex.delimiter.test(from)) return new SVG.Array(from).morph(to)\r\n    // prepare number for morphing\r\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\r\n    // prepare for plain morphing\r\n    this.value = from\r\n    this.destination = to\r\n  }\r\n\r\n, extend: {\r\n    at: function(pos, real){\r\n      return real < 1 ? this.value : this.destination\r\n    },\r\n\r\n    valueOf: function(){\r\n      return this.value\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  // Add animatable attributes\r\n  attr: function(a, v, relative) {\r\n    // apply attributes individually\r\n    if (typeof a == 'object') {\r\n      for (var key in a)\r\n        this.attr(key, a[key])\r\n\r\n    } else {\r\n      this.add(a, v, 'attrs')\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable styles\r\n, style: function(s, v) {\r\n    if (typeof s == 'object')\r\n      for (var key in s)\r\n        this.style(key, s[key])\r\n\r\n    else\r\n      this.add(s, v, 'styles')\r\n\r\n    return this\r\n  }\r\n  // Animatable x-axis\r\n, x: function(x, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({x:x}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(x)\r\n    num.relative = relative\r\n    return this.add('x', num)\r\n  }\r\n  // Animatable y-axis\r\n, y: function(y, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({y:y}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(y)\r\n    num.relative = relative\r\n    return this.add('y', num)\r\n  }\r\n  // Animatable center x-axis\r\n, cx: function(x) {\r\n    return this.add('cx', new SVG.Number(x))\r\n  }\r\n  // Animatable center y-axis\r\n, cy: function(y) {\r\n    return this.add('cy', new SVG.Number(y))\r\n  }\r\n  // Add animatable move\r\n, move: function(x, y) {\r\n    return this.x(x).y(y)\r\n  }\r\n  // Add animatable center\r\n, center: function(x, y) {\r\n    return this.cx(x).cy(y)\r\n  }\r\n  // Add animatable size\r\n, size: function(width, height) {\r\n    if (this.target() instanceof SVG.Text) {\r\n      // animate font size for Text elements\r\n      this.attr('font-size', width)\r\n\r\n    } else {\r\n      // animate bbox based size for all other elements\r\n      var box\r\n\r\n      if(!width || !height){\r\n        box = this.target().bbox()\r\n      }\r\n\r\n      if(!width){\r\n        width = box.width / box.height  * height\r\n      }\r\n\r\n      if(!height){\r\n        height = box.height / box.width  * width\r\n      }\r\n\r\n      this.add('width' , new SVG.Number(width))\r\n          .add('height', new SVG.Number(height))\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable width\r\n, width: function(width) {\r\n    return this.add('width', new SVG.Number(width))\r\n  }\r\n  // Add animatable height\r\n, height: function(height) {\r\n    return this.add('height', new SVG.Number(height))\r\n  }\r\n  // Add animatable plot\r\n, plot: function(a, b, c, d) {\r\n    // Lines can be plotted with 4 arguments\r\n    if(arguments.length == 4) {\r\n      return this.plot([a, b, c, d])\r\n    }\r\n\r\n    return this.add('plot', new (this.target().morphArray)(a))\r\n  }\r\n  // Add leading method\r\n, leading: function(value) {\r\n    return this.target().leading ?\r\n      this.add('leading', new SVG.Number(value)) :\r\n      this\r\n  }\r\n  // Add animatable viewbox\r\n, viewbox: function(x, y, width, height) {\r\n    if (this.target() instanceof SVG.Container) {\r\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n    return this\r\n  }\r\n, update: function(o) {\r\n    if (this.target() instanceof SVG.Stop) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        return this.update({\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        })\r\n      }\r\n\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', o.offset)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\r\n\nSVG.Box = SVG.invent({\r\n  create: function(x, y, width, height) {\r\n    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n      // chromes getBoundingClientRect has no x and y property\r\n      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n    } else if (arguments.length == 4) {\r\n      this.x = x\r\n      this.y = y\r\n      this.width = width\r\n      this.height = height\r\n    }\r\n\r\n    // add center, right, bottom...\r\n    fullBox(this)\r\n  }\r\n, extend: {\r\n    // Merge rect box with another, return a new instance\r\n    merge: function(box) {\r\n      var b = new this.constructor()\r\n\r\n      // merge boxes\r\n      b.x      = Math.min(this.x, box.x)\r\n      b.y      = Math.min(this.y, box.y)\r\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\r\n      return fullBox(b)\r\n    }\r\n\r\n  , transform: function(m) {\r\n      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p, bbox\r\n\r\n      var pts = [\r\n        new SVG.Point(this.x, this.y),\r\n        new SVG.Point(this.x2, this.y),\r\n        new SVG.Point(this.x, this.y2),\r\n        new SVG.Point(this.x2, this.y2)\r\n      ]\r\n\r\n      pts.forEach(function(p) {\r\n        p = p.transform(m)\r\n        xMin = Math.min(xMin,p.x)\r\n        xMax = Math.max(xMax,p.x)\r\n        yMin = Math.min(yMin,p.y)\r\n        yMax = Math.max(yMax,p.y)\r\n      })\r\n\r\n      bbox = new this.constructor()\r\n      bbox.x = xMin\r\n      bbox.width = xMax-xMin\r\n      bbox.y = yMin\r\n      bbox.height = yMax-yMin\r\n\r\n      fullBox(bbox)\r\n\r\n      return bbox\r\n    }\r\n  }\r\n})\r\n\r\nSVG.BBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    // get values if element is given\r\n    if (element instanceof SVG.Element) {\r\n      var box\r\n\r\n      // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered\r\n      try {\r\n\r\n        if (!document.documentElement.contains){\r\n          // This is IE - it does not support contains() for top-level SVGs\r\n          var topParent = element.node\r\n          while (topParent.parentNode){\r\n            topParent = topParent.parentNode\r\n          }\r\n          if (topParent != document) throw new Exception('Element not in the dom')\r\n        } else {\r\n          // the element is NOT in the dom, throw error\r\n          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n        }\r\n\r\n        // find native bbox\r\n        box = element.node.getBBox()\r\n      } catch(e) {\r\n        if(element instanceof SVG.Shape){\r\n          var clone = element.clone(SVG.parser.draw.instance).show()\r\n          box = clone.node.getBBox()\r\n          clone.remove()\r\n        }else{\r\n          box = {\r\n            x:      element.node.clientLeft\r\n          , y:      element.node.clientTop\r\n          , width:  element.node.clientWidth\r\n          , height: element.node.clientHeight\r\n          }\r\n        }\r\n      }\r\n\r\n      SVG.Box.call(this, box)\r\n    }\r\n\r\n  }\r\n\r\n  // Define ancestor\r\n, inherit: SVG.Box\r\n\r\n  // Define Parent\r\n, parent: SVG.Element\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get bounding box\r\n    bbox: function() {\r\n      return new SVG.BBox(this)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.BBox.prototype.constructor = SVG.BBox\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  tbox: function(){\r\n    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n    return this.rbox(this.doc())\r\n  }\r\n})\r\n\r\nSVG.RBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    if (element instanceof SVG.Element) {\r\n      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n    }\r\n  }\r\n\r\n, inherit: SVG.Box\r\n\r\n  // define Parent\r\n, parent: SVG.Element\r\n\r\n, extend: {\r\n    addOffset: function() {\r\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n      this.x += window.pageXOffset\r\n      this.y += window.pageYOffset\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get rect box\r\n    rbox: function(el) {\r\n      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n      return new SVG.RBox(this).addOffset()\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.RBox.prototype.constructor = SVG.RBox\r\n\nSVG.Matrix = SVG.invent({\r\n  // Initialize\r\n  create: function(source) {\r\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\r\n    // ensure source as object\r\n    source = source instanceof SVG.Element ?\r\n      source.matrixify() :\r\n    typeof source === 'string' ?\r\n      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n    arguments.length == 6 ?\r\n      arrayToMatrix([].slice.call(arguments)) :\r\n    Array.isArray(source) ?\r\n      arrayToMatrix(source) :\r\n    typeof source === 'object' ?\r\n      source : base\r\n\r\n    // merge source\r\n    for (i = abcdef.length - 1; i >= 0; --i)\r\n      this[abcdef[i]] = source[abcdef[i]] != null ?\r\n        source[abcdef[i]] : base[abcdef[i]]\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Extract individual transformations\r\n    extract: function() {\r\n      // find delta transform points\r\n      var px    = deltaTransformPoint(this, 0, 1)\r\n        , py    = deltaTransformPoint(this, 1, 0)\r\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\r\n      return {\r\n        // translation\r\n        x:        this.e\r\n      , y:        this.f\r\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // skew\r\n      , skewX:    -skewX\r\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n        // scale\r\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // rotation\r\n      , rotation: skewX\r\n      , a: this.a\r\n      , b: this.b\r\n      , c: this.c\r\n      , d: this.d\r\n      , e: this.e\r\n      , f: this.f\r\n      , matrix: new SVG.Matrix(this)\r\n      }\r\n    }\r\n    // Clone matrix\r\n  , clone: function() {\r\n      return new SVG.Matrix(this)\r\n    }\r\n    // Morph one matrix into another\r\n  , morph: function(matrix) {\r\n      // store new destination\r\n      this.destination = new SVG.Matrix(matrix)\r\n\r\n      return this\r\n    }\r\n    // Get morphed matrix at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var matrix = new SVG.Matrix({\r\n        a: this.a + (this.destination.a - this.a) * pos\r\n      , b: this.b + (this.destination.b - this.b) * pos\r\n      , c: this.c + (this.destination.c - this.c) * pos\r\n      , d: this.d + (this.destination.d - this.d) * pos\r\n      , e: this.e + (this.destination.e - this.e) * pos\r\n      , f: this.f + (this.destination.f - this.f) * pos\r\n      })\r\n\r\n      return matrix\r\n    }\r\n    // Multiplies by given matrix\r\n  , multiply: function(matrix) {\r\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n    }\r\n    // Inverses matrix\r\n  , inverse: function() {\r\n      return new SVG.Matrix(this.native().inverse())\r\n    }\r\n    // Translate matrix\r\n  , translate: function(x, y) {\r\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n    }\r\n    // Scale matrix\r\n  , scale: function(x, y, cx, cy) {\r\n      // support uniformal scale\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n    }\r\n    // Rotate matrix\r\n  , rotate: function(r, cx, cy) {\r\n      // convert degrees to radians\r\n      r = SVG.utils.radians(r)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n    }\r\n    // Flip matrix on x or y, at a given offset\r\n  , flip: function(a, o) {\r\n      return a == 'x' ?\r\n          this.scale(-1, 1, o, 0) :\r\n        a == 'y' ?\r\n          this.scale(1, -1, 0, o) :\r\n          this.scale(-1, -1, a, o != null ? o : a)\r\n    }\r\n    // Skew\r\n  , skew: function(x, y, cx, cy) {\r\n      // support uniformal skew\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      // convert degrees to radians\r\n      x = SVG.utils.radians(x)\r\n      y = SVG.utils.radians(y)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n    }\r\n    // SkewX\r\n  , skewX: function(x, cx, cy) {\r\n      return this.skew(x, 0, cx, cy)\r\n    }\r\n    // SkewY\r\n  , skewY: function(y, cx, cy) {\r\n      return this.skew(0, y, cx, cy)\r\n    }\r\n    // Transform around a center point\r\n  , around: function(cx, cy, matrix) {\r\n      return this\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n        .multiply(matrix)\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n    }\r\n    // Convert to native SVGMatrix\r\n  , native: function() {\r\n      // create new matrix\r\n      var matrix = SVG.parser.native.createSVGMatrix()\r\n\r\n      // update with current values\r\n      for (var i = abcdef.length - 1; i >= 0; i--)\r\n        matrix[abcdef[i]] = this[abcdef[i]]\r\n\r\n      return matrix\r\n    }\r\n    // Convert matrix to string\r\n  , toString: function() {\r\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n    }\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Element\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Get current matrix\r\n    ctm: function() {\r\n      return new SVG.Matrix(this.node.getCTM())\r\n    },\r\n    // Get current screen matrix\r\n    screenCTM: function() {\r\n      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n         This is needed because FF does not return the transformation matrix\r\n         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n         However all other Browsers do that */\r\n      if(this instanceof SVG.Nested) {\r\n        var rect = this.rect(1,1)\r\n        var m = rect.node.getScreenCTM()\r\n        rect.remove()\r\n        return new SVG.Matrix(m)\r\n      }\r\n      return new SVG.Matrix(this.node.getScreenCTM())\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\nSVG.Point = SVG.invent({\r\n  // Initialize\r\n  create: function(x,y) {\r\n    var i, source, base = {x:0, y:0}\r\n\r\n    // ensure source as object\r\n    source = Array.isArray(x) ?\r\n      {x:x[0], y:x[1]} :\r\n    typeof x === 'object' ?\r\n      {x:x.x, y:x.y} :\r\n    x != null ?\r\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\r\n    // merge source\r\n    this.x = source.x\r\n    this.y = source.y\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Clone point\r\n    clone: function() {\r\n      return new SVG.Point(this)\r\n    }\r\n    // Morph one point into another\r\n  , morph: function(x, y) {\r\n      // store new destination\r\n      this.destination = new SVG.Point(x, y)\r\n\r\n      return this\r\n    }\r\n    // Get morphed point at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var point = new SVG.Point({\r\n        x: this.x + (this.destination.x - this.x) * pos\r\n      , y: this.y + (this.destination.y - this.y) * pos\r\n      })\r\n\r\n      return point\r\n    }\r\n    // Convert to native SVGPoint\r\n  , native: function() {\r\n      // create new point\r\n      var point = SVG.parser.native.createSVGPoint()\r\n\r\n      // update with current values\r\n      point.x = this.x\r\n      point.y = this.y\r\n\r\n      return point\r\n    }\r\n    // transform point with matrix\r\n  , transform: function(matrix) {\r\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n\r\n  // Get point\r\n  point: function(x, y) {\r\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Set svg element attribute\r\n  attr: function(a, v, n) {\r\n    // act as full getter\r\n    if (a == null) {\r\n      // get an object of attributes\r\n      a = {}\r\n      v = this.node.attributes\r\n      for (n = v.length - 1; n >= 0; n--)\r\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n\r\n      return a\r\n\r\n    } else if (typeof a == 'object') {\r\n      // apply every attribute individually if an object is passed\r\n      for (v in a) this.attr(v, a[v])\r\n\r\n    } else if (v === null) {\r\n        // remove value\r\n        this.node.removeAttribute(a)\r\n\r\n    } else if (v == null) {\r\n      // act as a getter if the first and only argument is not an object\r\n      v = this.node.getAttribute(a)\r\n      return v == null ?\r\n        SVG.defaults.attrs[a] :\r\n      SVG.regex.isNumber.test(v) ?\r\n        parseFloat(v) : v\r\n\r\n    } else {\r\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n      if (a == 'stroke-width')\r\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n      else if (a == 'stroke')\r\n        this._stroke = v\r\n\r\n      // convert image fill and stroke to patterns\r\n      if (a == 'fill' || a == 'stroke') {\r\n        if (SVG.regex.isImage.test(v))\r\n          v = this.doc().defs().image(v, 0, 0)\r\n\r\n        if (v instanceof SVG.Image)\r\n          v = this.doc().defs().pattern(0, 0, function() {\r\n            this.add(v)\r\n          })\r\n      }\r\n\r\n      // ensure correct numeric values (also accepts NaN and Infinity)\r\n      if (typeof v === 'number')\r\n        v = new SVG.Number(v)\r\n\r\n      // ensure full hex color\r\n      else if (SVG.Color.isColor(v))\r\n        v = new SVG.Color(v)\r\n\r\n      // parse array values\r\n      else if (Array.isArray(v))\r\n        v = new SVG.Array(v)\r\n\r\n      // if the passed attribute is leading...\r\n      if (a == 'leading') {\r\n        // ... call the leading method instead\r\n        if (this.leading)\r\n          this.leading(v)\r\n      } else {\r\n        // set given attribute on node\r\n        typeof n === 'string' ?\r\n          this.node.setAttributeNS(n, a, v.toString()) :\r\n          this.node.setAttribute(a, v.toString())\r\n      }\r\n\r\n      // rebuild if required\r\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n        this.rebuild(a, v)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Add transformations\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // get current matrix\r\n    matrix = new SVG.Matrix(target)\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.multiply(new SVG.Matrix(o)) :\r\n        // absolute\r\n        new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n        // absolute\r\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      if (!relative) {\r\n        // absolute; multiply inversed values\r\n        var e = matrix.extract()\r\n        o.scaleX = o.scaleX * 1 / e.scaleX\r\n        o.scaleY = o.scaleY * 1 / e.scaleY\r\n      }\r\n\r\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\r\n      if (!relative) {\r\n        // absolute; reset skew values\r\n        var e = matrix.extract()\r\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n      }\r\n\r\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      if (relative) {\r\n        // relative\r\n        matrix = matrix.translate(o.x, o.y)\r\n      } else {\r\n        // absolute\r\n        if (o.x != null) matrix.e = o.x\r\n        if (o.y != null) matrix.f = o.y\r\n      }\r\n    }\r\n\r\n    return this.attr('transform', matrix)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this.target()\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skewY != null ? o.skewY : 0\r\n\r\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      matrix = new SVG.Translate(o.x, o.y)\r\n    }\r\n\r\n    if(!matrix) return this\r\n\r\n    matrix.relative = relative\r\n\r\n    this.last().transforms.push(matrix)\r\n\r\n    return this._callStart()\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Reset all transformations\r\n  untransform: function() {\r\n    return this.attr('transform', null)\r\n  },\r\n  // merge the whole transformation chain into one matrix and returns it\r\n  matrixify: function() {\r\n\r\n    var matrix = (this.attr('transform') || '')\r\n      // split transformations\r\n      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n        // generate key => value pairs\r\n        var kv = str.trim().split('(')\r\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n      })\r\n      // merge every transformation into one matrix\r\n      .reduce(function(matrix, transform){\r\n\r\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n        return matrix[transform[0]].apply(matrix, transform[1])\r\n\r\n      }, new SVG.Matrix())\r\n\r\n    return matrix\r\n  },\r\n  // add an element to another parent without changing the visual representation on the screen\r\n  toParent: function(parent) {\r\n    if(this == parent) return this\r\n    var ctm = this.screenCTM()\r\n    var pCtm = parent.screenCTM().inverse()\r\n\r\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\r\n    return this\r\n  },\r\n  // same as above with parent equals root-svg\r\n  toDoc: function() {\r\n    return this.toParent(this.doc())\r\n  }\r\n\r\n})\r\n\r\nSVG.Transformation = SVG.invent({\r\n\r\n  create: function(source, inversed){\r\n\r\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n      return this.constructor.call(this, [].slice.call(arguments))\r\n    }\r\n\r\n    if(Array.isArray(source)){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[i]\r\n      }\r\n    } else if(typeof source == 'object'){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[this.arguments[i]]\r\n      }\r\n    }\r\n\r\n    this.inversed = false\r\n\r\n    if(inversed === true){\r\n      this.inversed = true\r\n    }\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    arguments: []\r\n  , method: ''\r\n\r\n  , at: function(pos){\r\n\r\n      var params = []\r\n\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        params.push(this[this.arguments[i]])\r\n      }\r\n\r\n      var m = this._undo || new SVG.Matrix()\r\n\r\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\r\n      return this.inversed ? m.inverse() : m\r\n\r\n    }\r\n\r\n  , undo: function(o){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n      }\r\n\r\n      // The method SVG.Matrix.extract which was used before calling this\r\n      // method to obtain a value for the parameter o doesn't return a cx and\r\n      // a cy so we use the ones that were provided to this object at its creation\r\n      o.cx = this.cx\r\n      o.cy = this.cy\r\n\r\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.Translate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['transformedX', 'transformedY']\r\n  , method: 'translate'\r\n  }\r\n\r\n})\r\n\r\nSVG.Rotate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['rotation', 'cx', 'cy']\r\n  , method: 'rotate'\r\n  , at: function(pos){\r\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n      return this.inversed ? m.inverse() : m\r\n    }\r\n  , undo: function(o){\r\n      this._undo = o\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Scale = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n  , method: 'scale'\r\n  }\r\n\r\n})\r\n\r\nSVG.Skew = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n  , method: 'skew'\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Dynamic style generator\r\n  style: function(s, v) {\r\n    if (arguments.length == 0) {\r\n      // get full style\r\n      return this.node.style.cssText || ''\r\n\r\n    } else if (arguments.length < 2) {\r\n      // apply every style individually if an object is passed\r\n      if (typeof s == 'object') {\r\n        for (v in s) this.style(v, s[v])\r\n\r\n      } else if (SVG.regex.isCss.test(s)) {\r\n        // parse css string\r\n        s = s.split(/\\s*;\\s*/)\r\n          // filter out suffix ; and stuff like ;;\r\n          .filter(function(e) { return !!e })\r\n          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\r\n        // apply every definition individually\r\n        while (v = s.pop()) {\r\n          this.style(v[0], v[1])\r\n        }\r\n      } else {\r\n        // act as a getter if the first and only argument is not an object\r\n        return this.node.style[camelCase(s)]\r\n      }\r\n\r\n    } else {\r\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.Parent = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Returns all child elements\r\n    children: function() {\r\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n        return SVG.adopt(node)\r\n      })\r\n    }\r\n    // Add given element at a position\r\n  , add: function(element, i) {\r\n      if (i == null)\r\n        this.node.appendChild(element.node)\r\n      else if (element.node != this.node.childNodes[i])\r\n        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\r\n      return this\r\n    }\r\n    // Basically does the same as `add()` but returns the added element instead\r\n  , put: function(element, i) {\r\n      this.add(element, i)\r\n      return element\r\n    }\r\n    // Checks if the given element is a child\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // Gets index of given element\r\n  , index: function(element) {\r\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n    }\r\n    // Get a element at the given index\r\n  , get: function(i) {\r\n      return SVG.adopt(this.node.childNodes[i])\r\n    }\r\n    // Get first child\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get the last child\r\n  , last: function() {\r\n      return this.get(this.node.childNodes.length - 1)\r\n    }\r\n    // Iterates over all children and invokes a given block\r\n  , each: function(block, deep) {\r\n      var i, il\r\n        , children = this.children()\r\n\r\n      for (i = 0, il = children.length; i < il; i++) {\r\n        if (children[i] instanceof SVG.Element)\r\n          block.apply(children[i], [i, children])\r\n\r\n        if (deep && (children[i] instanceof SVG.Container))\r\n          children[i].each(block, deep)\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove a given child\r\n  , removeElement: function(element) {\r\n      this.node.removeChild(element.node)\r\n\r\n      return this\r\n    }\r\n    // Remove all elements in this container\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      return this\r\n    }\r\n  , // Get defs\r\n    defs: function() {\r\n      return this.doc().defs()\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Parent, {\r\n\r\n  ungroup: function(parent, depth) {\r\n    if(depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this\r\n\r\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n    depth = depth || Infinity\r\n\r\n    this.each(function(){\r\n      if(this instanceof SVG.Defs) return this\r\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n      return this.toParent(parent)\r\n    })\r\n\r\n    this.node.firstChild || this.remove()\r\n\r\n    return this\r\n  },\r\n\r\n  flatten: function(parent, depth) {\r\n    return this.ungroup(parent, depth)\r\n  }\r\n\r\n})\nSVG.Container = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n})\n\r\nSVG.ViewBox = SVG.invent({\r\n\r\n  create: function(source) {\r\n    var i, base = [0, 0, 0, 0]\r\n\r\n    var x, y, width, height, box, view, we, he\r\n      , wm   = 1 // width multiplier\r\n      , hm   = 1 // height multiplier\r\n      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\r\n    if(source instanceof SVG.Element){\r\n\r\n      we = source\r\n      he = source\r\n      view = (source.attr('viewBox') || '').match(reg)\r\n      box = source.bbox\r\n\r\n      // get dimensions of current node\r\n      width  = new SVG.Number(source.width())\r\n      height = new SVG.Number(source.height())\r\n\r\n      // find nearest non-percentual dimensions\r\n      while (width.unit == '%') {\r\n        wm *= width.value\r\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n        we = we.parent()\r\n      }\r\n      while (height.unit == '%') {\r\n        hm *= height.value\r\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n        he = he.parent()\r\n      }\r\n\r\n      // ensure defaults\r\n      this.x      = 0\r\n      this.y      = 0\r\n      this.width  = width  * wm\r\n      this.height = height * hm\r\n      this.zoom   = 1\r\n\r\n      if (view) {\r\n        // get width and height from viewbox\r\n        x      = parseFloat(view[0])\r\n        y      = parseFloat(view[1])\r\n        width  = parseFloat(view[2])\r\n        height = parseFloat(view[3])\r\n\r\n        // calculate zoom accoring to viewbox\r\n        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n          this.height / height :\r\n          this.width  / width\r\n\r\n        // calculate real pixel dimensions on parent SVG.Doc element\r\n        this.x      = x\r\n        this.y      = y\r\n        this.width  = width\r\n        this.height = height\r\n\r\n      }\r\n\r\n    }else{\r\n\r\n      // ensure source as object\r\n      source = typeof source === 'string' ?\r\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n      Array.isArray(source) ?\r\n        source :\r\n      typeof source == 'object' ?\r\n        [source.x, source.y, source.width, source.height] :\r\n      arguments.length == 4 ?\r\n        [].slice.call(arguments) :\r\n        base\r\n\r\n      this.x = source[0]\r\n      this.y = source[1]\r\n      this.width = source[2]\r\n      this.height = source[3]\r\n    }\r\n\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    toString: function() {\r\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n    }\r\n  , morph: function(x, y, width, height){\r\n      this.destination = new SVG.ViewBox(x, y, width, height)\r\n      return this\r\n    }\r\n\r\n  , at: function(pos) {\r\n\r\n      if(!this.destination) return this\r\n\r\n      return new SVG.ViewBox([\r\n          this.x + (this.destination.x - this.x) * pos\r\n        , this.y + (this.destination.y - this.y) * pos\r\n        , this.width + (this.destination.width - this.width) * pos\r\n        , this.height + (this.destination.height - this.height) * pos\r\n      ])\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n\r\n    // get/set viewbox\r\n    viewbox: function(x, y, width, height) {\r\n      if (arguments.length == 0)\r\n        // act as a getter if there are no arguments\r\n        return new SVG.ViewBox(this)\r\n\r\n      // otherwise act as a setter\r\n      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n  }\r\n\r\n})\n// Add events to elements\r\n;[  'click'\r\n  , 'dblclick'\r\n  , 'mousedown'\r\n  , 'mouseup'\r\n  , 'mouseover'\r\n  , 'mouseout'\r\n  , 'mousemove'\r\n  // , 'mouseenter' -> not supported by IE\r\n  // , 'mouseleave' -> not supported by IE\r\n  , 'touchstart'\r\n  , 'touchmove'\r\n  , 'touchleave'\r\n  , 'touchend'\r\n  , 'touchcancel' ].forEach(function(event) {\r\n\r\n  // add event to SVG.Element\r\n  SVG.Element.prototype[event] = function(f) {\r\n    // bind event to element rather than element node\r\n    SVG.on(this.node, event, f)\r\n    return this\r\n  }\r\n})\r\n\r\n// Initialize listeners stack\r\nSVG.listeners = []\r\nSVG.handlerMap = []\r\nSVG.listenerId = 0\r\n\r\n// Add event binder in the SVG namespace\r\nSVG.on = function(node, event, listener, binding, options) {\r\n  // create listener, get object-index\r\n  var l     = listener.bind(binding || node.instance || node)\r\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n    , ev    = event.split('.')[0]\r\n    , ns    = event.split('.')[1] || '*'\r\n\r\n\r\n  // ensure valid object\r\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\r\n  if(!listener._svgjsListenerId)\r\n    listener._svgjsListenerId = ++SVG.listenerId\r\n\r\n  // reference listener\r\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\r\n  // add listener\r\n  node.addEventListener(ev, l, options || false)\r\n}\r\n\r\n// Add event unbinder in the SVG namespace\r\nSVG.off = function(node, event, listener) {\r\n  var index = SVG.handlerMap.indexOf(node)\r\n    , ev    = event && event.split('.')[0]\r\n    , ns    = event && event.split('.')[1]\r\n    , namespace = ''\r\n\r\n  if(index == -1) return\r\n\r\n  if (listener) {\r\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n    if(!listener) return\r\n\r\n    // remove listener reference\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n      // remove listener\r\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\r\n      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n    }\r\n\r\n  } else if (ns && ev) {\r\n    // remove all listeners for a namespaced event\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n      for (listener in SVG.listeners[index][ev][ns])\r\n        SVG.off(node, [ev, ns].join('.'), listener)\r\n\r\n      delete SVG.listeners[index][ev][ns]\r\n    }\r\n\r\n  } else if (ns){\r\n    // remove all listeners for a specific namespace\r\n    for(event in SVG.listeners[index]){\r\n        for(namespace in SVG.listeners[index][event]){\r\n            if(ns === namespace){\r\n                SVG.off(node, [event, ns].join('.'))\r\n            }\r\n        }\r\n    }\r\n\r\n  } else if (ev) {\r\n    // remove all listeners for the event\r\n    if (SVG.listeners[index][ev]) {\r\n      for (namespace in SVG.listeners[index][ev])\r\n        SVG.off(node, [ev, namespace].join('.'))\r\n\r\n      delete SVG.listeners[index][ev]\r\n    }\r\n\r\n  } else {\r\n    // remove all listeners on a given node\r\n    for (event in SVG.listeners[index])\r\n      SVG.off(node, event)\r\n\r\n    delete SVG.listeners[index]\r\n    delete SVG.handlerMap[index]\r\n\r\n  }\r\n}\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Bind given event to listener\r\n  on: function(event, listener, binding, options) {\r\n    SVG.on(this.node, event, listener, binding, options)\r\n\r\n    return this\r\n  }\r\n  // Unbind event from listener\r\n, off: function(event, listener) {\r\n    SVG.off(this.node, event, listener)\r\n\r\n    return this\r\n  }\r\n  // Fire given event\r\n, fire: function(event, data) {\r\n\r\n    // Dispatch event\r\n    if(event instanceof window.Event){\r\n        this.node.dispatchEvent(event)\r\n    }else{\r\n        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n    }\r\n\r\n    this._event = event\r\n    return this\r\n  }\r\n, event: function() {\r\n    return this._event\r\n  }\r\n})\r\n\n\r\nSVG.Defs = SVG.invent({\r\n  // Initialize node\r\n  create: 'defs'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n})\nSVG.G = SVG.invent({\r\n  // Initialize node\r\n  create: 'g'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n    }\r\n  , gbox: function() {\r\n\r\n      var bbox  = this.bbox()\r\n        , trans = this.transform()\r\n\r\n      bbox.x  += trans.x\r\n      bbox.x2 += trans.x\r\n      bbox.cx += trans.x\r\n\r\n      bbox.y  += trans.y\r\n      bbox.y2 += trans.y\r\n      bbox.cy += trans.y\r\n\r\n      return bbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a group element\r\n    group: function() {\r\n      return this.put(new SVG.G)\r\n    }\r\n  }\r\n})\r\n\n// ### This module adds backward / forward functionality to elements.\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Get all siblings, including myself\r\n  siblings: function() {\r\n    return this.parent().children()\r\n  }\r\n  // Get the curent position siblings\r\n, position: function() {\r\n    return this.parent().index(this)\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, next: function() {\r\n    return this.siblings()[this.position() + 1]\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, previous: function() {\r\n    return this.siblings()[this.position() - 1]\r\n  }\r\n  // Send given element one step forward\r\n, forward: function() {\r\n    var i = this.position() + 1\r\n      , p = this.parent()\r\n\r\n    // move node one step forward\r\n    p.removeElement(this).add(this, i)\r\n\r\n    // make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element one step backward\r\n, backward: function() {\r\n    var i = this.position()\r\n\r\n    if (i > 0)\r\n      this.parent().removeElement(this).add(this, i - 1)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the front\r\n, front: function() {\r\n    var p = this.parent()\r\n\r\n    // Move node forward\r\n    p.node.appendChild(this.node)\r\n\r\n    // Make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the back\r\n, back: function() {\r\n    if (this.position() > 0)\r\n      this.parent().removeElement(this).add(this, 0)\r\n\r\n    return this\r\n  }\r\n  // Inserts a given element before the targeted element\r\n, before: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i)\r\n\r\n    return this\r\n  }\r\n  // Insters a given element after the targeted element\r\n, after: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i + 1)\r\n\r\n    return this\r\n  }\r\n\r\n})\nSVG.Mask = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('mask'))\r\n\r\n    // keep references to masked elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unmask all masked elements and remove itself\r\n    remove: function() {\r\n      // unmask all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unmask()\r\n      this.targets = []\r\n\r\n      // remove mask from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create masking element\r\n    mask: function() {\r\n      return this.defs().put(new SVG.Mask)\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Distribute mask to svg element\r\n  maskWith: function(element) {\r\n    // use given mask or create a new one\r\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.masker.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n  }\r\n  // Unmask element\r\n, unmask: function() {\r\n    delete this.masker\r\n    return this.attr('mask', null)\r\n  }\r\n\r\n})\r\n\nSVG.ClipPath = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('clipPath'))\r\n\r\n    // keep references to clipped elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unclip all clipped elements and remove itself\r\n    remove: function() {\r\n      // unclip all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unclip()\r\n      this.targets = []\r\n\r\n      // remove clipPath from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create clipping element\r\n    clip: function() {\r\n      return this.defs().put(new SVG.ClipPath)\r\n    }\r\n  }\r\n})\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Distribute clipPath to svg element\r\n  clipWith: function(element) {\r\n    // use given clip or create a new one\r\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.clipper.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n  }\r\n  // Unclip element\r\n, unclip: function() {\r\n    delete this.clipper\r\n    return this.attr('clip-path', null)\r\n  }\r\n\r\n})\nSVG.Gradient = SVG.invent({\r\n  // Initialize node\r\n  create: function(type) {\r\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n\r\n    // store type\r\n    this.type = type\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add a color stop\r\n    at: function(offset, color, opacity) {\r\n      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n    }\r\n    // Update gradient\r\n  , update: function(block) {\r\n      // remove all stops\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'gradientTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create gradient element in defs\r\n    gradient: function(type, block) {\r\n      return this.defs().gradient(type, block)\r\n    }\r\n  }\r\n})\r\n\r\n// Add animatable methods to both gradient and fx module\r\nSVG.extend(SVG.Gradient, SVG.FX, {\r\n  // From position\r\n  from: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n  }\r\n  // To position\r\n, to: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n  }\r\n})\r\n\r\n// Base gradient generation\r\nSVG.extend(SVG.Defs, {\r\n  // define gradient\r\n  gradient: function(type, block) {\r\n    return this.put(new SVG.Gradient(type)).update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.Stop = SVG.invent({\r\n  // Initialize node\r\n  create: 'stop'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // add color stops\r\n    update: function(o) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        o = {\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        }\r\n      }\r\n\r\n      // set attributes\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Pattern = SVG.invent({\r\n  // Initialize node\r\n  create: 'pattern'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Return the fill id\r\n    fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Update pattern by rebuilding\r\n  , update: function(block) {\r\n      // remove content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'patternTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create pattern element in defs\r\n    pattern: function(width, height, block) {\r\n      return this.defs().pattern(width, height, block)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Define gradient\r\n  pattern: function(width, height, block) {\r\n    return this.put(new SVG.Pattern).update(block).attr({\r\n      x:            0\r\n    , y:            0\r\n    , width:        width\r\n    , height:       height\r\n    , patternUnits: 'userSpaceOnUse'\r\n    })\r\n  }\r\n\r\n})\nSVG.Doc = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    if (element) {\r\n      // ensure the presence of a dom element\r\n      element = typeof element == 'string' ?\r\n        document.getElementById(element) :\r\n        element\r\n\r\n      // If the target is an svg element, use that element as the main wrapper.\r\n      // This allows svg.js to work with svg documents as well.\r\n      if (element.nodeName == 'svg') {\r\n        this.constructor.call(this, element)\r\n      } else {\r\n        this.constructor.call(this, SVG.create('svg'))\r\n        element.appendChild(this.node)\r\n        this.size('100%', '100%')\r\n      }\r\n\r\n      // set svg element attributes and ensure defs node\r\n      this.namespace().defs()\r\n    }\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add namespaces\r\n    namespace: function() {\r\n      return this\r\n        .attr({ xmlns: SVG.ns, version: '1.1' })\r\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\r\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\r\n    }\r\n    // Creates and returns defs element\r\n  , defs: function() {\r\n      if (!this._defs) {\r\n        var defs\r\n\r\n        // Find or create a defs element in this instance\r\n        if (defs = this.node.getElementsByTagName('defs')[0])\r\n          this._defs = SVG.adopt(defs)\r\n        else\r\n          this._defs = new SVG.Defs\r\n\r\n        // Make sure the defs node is at the end of the stack\r\n        this.node.appendChild(this._defs.node)\r\n      }\r\n\r\n      return this._defs\r\n    }\r\n    // custom parent method\r\n  , parent: function() {\r\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\r\n    }\r\n    // Fix for possible sub-pixel offset. See:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\r\n  , spof: function() {\r\n      var pos = this.node.getScreenCTM()\r\n\r\n      if (pos)\r\n        this\r\n          .style('left', (-pos.e % 1) + 'px')\r\n          .style('top',  (-pos.f % 1) + 'px')\r\n\r\n      return this\r\n    }\r\n\r\n      // Removes the doc from the DOM\r\n  , remove: function() {\r\n      if(this.parent()) {\r\n        this.parent().removeChild(this.node)\r\n      }\r\n\r\n      return this\r\n    }\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      // add back parser\r\n      if(!SVG.parser.draw.parentNode)\r\n        this.node.appendChild(SVG.parser.draw)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Shape = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n})\n\r\nSVG.Bare = SVG.invent({\r\n  // Initialize\r\n  create: function(element, inherit) {\r\n    // construct element\r\n    this.constructor.call(this, SVG.create(element))\r\n\r\n    // inherit custom methods\r\n    if (inherit)\r\n      for (var method in inherit.prototype)\r\n        if (typeof inherit.prototype[method] === 'function')\r\n          this[method] = inherit.prototype[method]\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Insert some plain text\r\n    words: function(text) {\r\n      // remove contents\r\n      while (this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // create text node\r\n      this.node.appendChild(document.createTextNode(text))\r\n\r\n      return this\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Create an element that is not described by SVG.js\r\n  element: function(element, inherit) {\r\n    return this.put(new SVG.Bare(element, inherit))\r\n  }\r\n})\r\n\nSVG.Symbol = SVG.invent({\r\n  // Initialize node\r\n  create: 'symbol'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n, construct: {\r\n    // create symbol\r\n    symbol: function() {\r\n      return this.put(new SVG.Symbol)\r\n    }\r\n  }\r\n})\r\n\nSVG.Use = SVG.invent({\r\n  // Initialize node\r\n  create: 'use'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Use element as a reference\r\n    element: function(element, file) {\r\n      // Set lined element\r\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a use element\r\n    use: function(element, file) {\r\n      return this.put(new SVG.Use).element(element, file)\r\n    }\r\n  }\r\n})\nSVG.Rect = SVG.invent({\r\n  // Initialize node\r\n  create: 'rect'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a rect element\r\n    rect: function(width, height) {\r\n      return this.put(new SVG.Rect()).size(width, height)\r\n    }\r\n  }\r\n})\nSVG.Circle = SVG.invent({\r\n  // Initialize node\r\n  create: 'circle'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create circle element, based on ellipse\r\n    circle: function(size) {\r\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Circle, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('r', rx)\r\n  }\r\n  // Alias radius x value\r\n, ry: function(ry) {\r\n    return this.rx(ry)\r\n  }\r\n})\r\n\r\nSVG.Ellipse = SVG.invent({\r\n  // Initialize node\r\n  create: 'ellipse'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create an ellipse\r\n    ellipse: function(width, height) {\r\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('rx', rx)\r\n  }\r\n  // Radius y value\r\n, ry: function(ry) {\r\n    return this.attr('ry', ry)\r\n  }\r\n})\r\n\r\n// Add common method\r\nSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n    }\r\n    // Custom size function\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .rx(new SVG.Number(p.width).divide(2))\r\n        .ry(new SVG.Number(p.height).divide(2))\r\n    }\r\n})\nSVG.Line = SVG.invent({\r\n  // Initialize node\r\n  create: 'line'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Get array\r\n    array: function() {\r\n      return new SVG.PointArray([\r\n        [ this.attr('x1'), this.attr('y1') ]\r\n      , [ this.attr('x2'), this.attr('y2') ]\r\n      ])\r\n    }\r\n    // Overwrite native plot() method\r\n  , plot: function(x1, y1, x2, y2) {\r\n      if (x1 == null)\r\n        return this.array()\r\n      else if (typeof y1 !== 'undefined')\r\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n      else\r\n        x1 = new SVG.PointArray(x1).toLine()\r\n\r\n      return this.attr(x1)\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr(this.array().move(x, y).toLine())\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr(this.array().size(p.width, p.height).toLine())\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a line element\r\n    line: function(x1, y1, x2, y2) {\r\n      // make sure plot is called as a setter\r\n      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n      return SVG.Line.prototype.plot.apply(\r\n        this.put(new SVG.Line)\r\n      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n      )\r\n    }\r\n  }\r\n})\r\n\nSVG.Polyline = SVG.invent({\r\n  // Initialize node\r\n  create: 'polyline'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polyline element\r\n    polyline: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.Polygon = SVG.invent({\r\n  // Initialize node\r\n  create: 'polygon'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polygon element\r\n    polygon: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\n// Add polygon-specific functions\r\nSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n  // Get array\r\n  array: function() {\r\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n  }\r\n  // Plot new path\r\n, plot: function(p) {\r\n    return (p == null) ?\r\n      this.array() :\r\n      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n  }\r\n  // Clear array cache\r\n, clear: function() {\r\n    delete this._array\r\n    return this\r\n  }\r\n  // Move by left top corner\r\n, move: function(x, y) {\r\n    return this.attr('points', this.array().move(x, y))\r\n  }\r\n  // Set element size to given width and height\r\n, size: function(width, height) {\r\n    var p = proportionalSize(this, width, height)\r\n\r\n    return this.attr('points', this.array().size(p.width, p.height))\r\n  }\r\n\r\n})\r\n\n// unify all point to point elements\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n  // Define morphable array\r\n  morphArray:  SVG.PointArray\r\n  // Move by left top corner over x-axis\r\n, x: function(x) {\r\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n  }\r\n  // Move by left top corner over y-axis\r\n, y: function(y) {\r\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n  }\r\n  // Set width of element\r\n, width: function(width) {\r\n    var b = this.bbox()\r\n\r\n    return width == null ? b.width : this.size(width, b.height)\r\n  }\r\n  // Set height of element\r\n, height: function(height) {\r\n    var b = this.bbox()\r\n\r\n    return height == null ? b.height : this.size(b.width, height)\r\n  }\r\n})\nSVG.Path = SVG.invent({\r\n  // Initialize node\r\n  create: 'path'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Define morphable array\r\n    morphArray:  SVG.PathArray\r\n    // Get array\r\n  , array: function() {\r\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n    }\r\n    // Plot new path\r\n  , plot: function(d) {\r\n      return (d == null) ?\r\n        this.array() :\r\n        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n    }\r\n    // Clear array cache\r\n  , clear: function() {\r\n      delete this._array\r\n      return this\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr('d', this.array().move(x, y))\r\n    }\r\n    // Move by left top corner over x-axis\r\n  , x: function(x) {\r\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n    }\r\n    // Move by left top corner over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr('d', this.array().size(p.width, p.height))\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped path element\r\n    path: function(d) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n    }\r\n  }\r\n})\r\n\nSVG.Image = SVG.invent({\r\n  // Initialize node\r\n  create: 'image'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // (re)load image\r\n    load: function(url) {\r\n      if (!url) return this\r\n\r\n      var self = this\r\n        , img  = new window.Image()\r\n\r\n      // preload image\r\n      SVG.on(img, 'load', function() {\r\n        SVG.off(img)\r\n\r\n        var p = self.parent(SVG.Pattern)\r\n\r\n        if(p === null) return\r\n\r\n        // ensure image size\r\n        if (self.width() == 0 && self.height() == 0)\r\n          self.size(img.width, img.height)\r\n\r\n        // ensure pattern size if not set\r\n        if (p && p.width() == 0 && p.height() == 0)\r\n          p.size(self.width(), self.height())\r\n\r\n        // callback\r\n        if (typeof self._loaded === 'function')\r\n          self._loaded.call(self, {\r\n            width:  img.width\r\n          , height: img.height\r\n          , ratio:  img.width / img.height\r\n          , url:    url\r\n          })\r\n      })\r\n\r\n      SVG.on(img, 'error', function(e){\r\n        SVG.off(img)\r\n\r\n        if (typeof self._error === 'function'){\r\n            self._error.call(self, e)\r\n        }\r\n      })\r\n\r\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n    }\r\n    // Add loaded callback\r\n  , loaded: function(loaded) {\r\n      this._loaded = loaded\r\n      return this\r\n    }\r\n\r\n  , error: function(error) {\r\n      this._error = error\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // create image element, load image and set its size\r\n    image: function(source, width, height) {\r\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n    }\r\n  }\r\n\r\n})\nSVG.Text = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('text'))\r\n\r\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n    this._rebuild = true                      // enable automatic updating of dy values\r\n    this._build   = false                     // disable build mode for adding multiple lines\r\n\r\n    // set default font\r\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      // act as getter\r\n      if (x == null)\r\n        return this.attr('x')\r\n\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      var oy = this.attr('y')\r\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\r\n      // act as getter\r\n      if (y == null)\r\n        return typeof oy === 'number' ? oy - o : oy\r\n\r\n      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n    }\r\n    // Move center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n    }\r\n    // Move center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n    }\r\n    // Set the text content\r\n  , text: function(text) {\r\n      // act as getter\r\n      if (typeof text === 'undefined'){\r\n        var text = ''\r\n        var children = this.node.childNodes\r\n        for(var i = 0, len = children.length; i < len; ++i){\r\n\r\n          // add newline if its not the first child and newLined is set to true\r\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n            text += '\\n'\r\n          }\r\n\r\n          // add content of this node\r\n          text += children[i].textContent\r\n        }\r\n\r\n        return text\r\n      }\r\n\r\n      // remove existing content\r\n      this.clear().build(true)\r\n\r\n      if (typeof text === 'function') {\r\n        // call block\r\n        text.call(this, this)\r\n\r\n      } else {\r\n        // store text and make sure text is not blank\r\n        text = text.split('\\n')\r\n\r\n        // build new lines\r\n        for (var i = 0, il = text.length; i < il; i++)\r\n          this.tspan(text[i]).newLine()\r\n      }\r\n\r\n      // disable build mode and rebuild lines\r\n      return this.build(false).rebuild()\r\n    }\r\n    // Set font size\r\n  , size: function(size) {\r\n      return this.attr('font-size', size).rebuild()\r\n    }\r\n    // Set / get leading\r\n  , leading: function(value) {\r\n      // act as getter\r\n      if (value == null)\r\n        return this.dom.leading\r\n\r\n      // act as setter\r\n      this.dom.leading = new SVG.Number(value)\r\n\r\n      return this.rebuild()\r\n    }\r\n    // Get all the first level lines\r\n  , lines: function() {\r\n      var node = (this.textPath && this.textPath() || this).node\r\n\r\n      // filter tspans and map them to SVG.js instances\r\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n        return SVG.adopt(el)\r\n      })\r\n\r\n      // return an instance of SVG.set\r\n      return new SVG.Set(lines)\r\n    }\r\n    // Rebuild appearance type\r\n  , rebuild: function(rebuild) {\r\n      // store new rebuild flag if given\r\n      if (typeof rebuild == 'boolean')\r\n        this._rebuild = rebuild\r\n\r\n      // define position of all lines\r\n      if (this._rebuild) {\r\n        var self = this\r\n          , blankLineOffset = 0\r\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n\r\n        this.lines().each(function() {\r\n          if (this.dom.newLined) {\r\n            if (!self.textPath())\r\n              this.attr('x', self.attr('x'))\r\n            if(this.text() == '\\n') {\r\n              blankLineOffset += dy\r\n            }else{\r\n              this.attr('dy', dy + blankLineOffset)\r\n              blankLineOffset = 0\r\n            }\r\n          }\r\n        })\r\n\r\n        this.fire('rebuild')\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Enable / disable build mode\r\n  , build: function(build) {\r\n      this._build = !!build\r\n      return this\r\n    }\r\n    // overwrite method from parent to set data properly\r\n  , setData: function(o){\r\n      this.dom = o\r\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create text element\r\n    text: function(text) {\r\n      return this.put(new SVG.Text).text(text)\r\n    }\r\n    // Create plain text element\r\n  , plain: function(text) {\r\n      return this.put(new SVG.Text).plain(text)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Tspan = SVG.invent({\r\n  // Initialize node\r\n  create: 'tspan'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set text content\r\n    text: function(text) {\r\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\r\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\r\n      return this\r\n    }\r\n    // Shortcut dx\r\n  , dx: function(dx) {\r\n      return this.attr('dx', dx)\r\n    }\r\n    // Shortcut dy\r\n  , dy: function(dy) {\r\n      return this.attr('dy', dy)\r\n    }\r\n    // Create new line\r\n  , newLine: function() {\r\n      // fetch text parent\r\n      var t = this.parent(SVG.Text)\r\n\r\n      // mark new line\r\n      this.dom.newLined = true\r\n\r\n      // apply new hyn\r\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Text, SVG.Tspan, {\r\n  // Create plain text node\r\n  plain: function(text) {\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // create text node\r\n    this.node.appendChild(document.createTextNode(text))\r\n\r\n    return this\r\n  }\r\n  // Create a tspan\r\n, tspan: function(text) {\r\n    var node  = (this.textPath && this.textPath() || this).node\r\n      , tspan = new SVG.Tspan\r\n\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // add new tspan\r\n    node.appendChild(tspan.node)\r\n\r\n    return tspan.text(text)\r\n  }\r\n  // Clear all lines\r\n, clear: function() {\r\n    var node = (this.textPath && this.textPath() || this).node\r\n\r\n    // remove existing child nodes\r\n    while (node.hasChildNodes())\r\n      node.removeChild(node.lastChild)\r\n\r\n    return this\r\n  }\r\n  // Get length of text element\r\n, length: function() {\r\n    return this.node.getComputedTextLength()\r\n  }\r\n})\r\n\nSVG.TextPath = SVG.invent({\r\n  // Initialize node\r\n  create: 'textPath'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n  // Define parent class\r\n, parent: SVG.Text\r\n\r\n  // Add parent method\r\n, construct: {\r\n    morphArray: SVG.PathArray\r\n    // Create path for text to run on\r\n  , path: function(d) {\r\n      // create textPath element\r\n      var path  = new SVG.TextPath\r\n        , track = this.doc().defs().path(d)\r\n\r\n      // move lines to textpath\r\n      while (this.node.hasChildNodes())\r\n        path.node.appendChild(this.node.firstChild)\r\n\r\n      // add textPath element as child node\r\n      this.node.appendChild(path.node)\r\n\r\n      // link textPath to path and add content\r\n      path.attr('href', '#' + track, SVG.xlink)\r\n\r\n      return this\r\n    }\r\n    // return the array of the path track element\r\n  , array: function() {\r\n      var track = this.track()\r\n\r\n      return track ? track.array() : null\r\n    }\r\n    // Plot path if any\r\n  , plot: function(d) {\r\n      var track = this.track()\r\n        , pathArray = null\r\n\r\n      if (track) {\r\n        pathArray = track.plot(d)\r\n      }\r\n\r\n      return (d == null) ? pathArray : this\r\n    }\r\n    // Get the path track element\r\n  , track: function() {\r\n      var path = this.textPath()\r\n\r\n      if (path)\r\n        return path.reference('href')\r\n    }\r\n    // Get the textPath child\r\n  , textPath: function() {\r\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n        return SVG.adopt(this.node.firstChild)\r\n    }\r\n  }\r\n})\r\n\nSVG.Nested = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('svg'))\r\n\r\n    this.style('overflow', 'visible')\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create nested svg document\r\n    nested: function() {\r\n      return this.put(new SVG.Nested)\r\n    }\r\n  }\r\n})\nSVG.A = SVG.invent({\r\n  // Initialize node\r\n  create: 'a'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Link url\r\n    to: function(url) {\r\n      return this.attr('href', url, SVG.xlink)\r\n    }\r\n    // Link show attribute\r\n  , show: function(target) {\r\n      return this.attr('show', target, SVG.xlink)\r\n    }\r\n    // Link target attribute\r\n  , target: function(target) {\r\n      return this.attr('target', target)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a hyperlink element\r\n    link: function(url) {\r\n      return this.put(new SVG.A).to(url)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Create a hyperlink element\r\n  linkTo: function(url) {\r\n    var link = new SVG.A\r\n\r\n    if (typeof url == 'function')\r\n      url.call(link, link)\r\n    else\r\n      link.to(url)\r\n\r\n    return this.parent().put(link).put(this)\r\n  }\r\n\r\n})\nSVG.Marker = SVG.invent({\r\n  // Initialize node\r\n  create: 'marker'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set width of element\r\n    width: function(width) {\r\n      return this.attr('markerWidth', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('markerHeight', height)\r\n    }\r\n    // Set marker refX and refY\r\n  , ref: function(x, y) {\r\n      return this.attr('refX', x).attr('refY', y)\r\n    }\r\n    // Update marker\r\n  , update: function(block) {\r\n      // remove all content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , toString: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    marker: function(width, height, block) {\r\n      // Create marker element in defs\r\n      return this.defs().marker(width, height, block)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Create marker\r\n  marker: function(width, height, block) {\r\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n    return this.put(new SVG.Marker)\r\n      .size(width, height)\r\n      .ref(width / 2, height / 2)\r\n      .viewbox(0, 0, width, height)\r\n      .attr('orient', 'auto')\r\n      .update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n  // Create and attach markers\r\n  marker: function(marker, width, height, block) {\r\n    var attr = ['marker']\r\n\r\n    // Build attribute name\r\n    if (marker != 'all') attr.push(marker)\r\n    attr = attr.join('-')\r\n\r\n    // Set marker attribute\r\n    marker = arguments[1] instanceof SVG.Marker ?\r\n      arguments[1] :\r\n      this.doc().marker(width, height, block)\r\n\r\n    return this.attr(attr, marker)\r\n  }\r\n\r\n})\n// Define list of available attributes for stroke and fill\r\nvar sugar = {\r\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n, fill:   ['color', 'opacity', 'rule']\r\n, prefix: function(t, a) {\r\n    return a == 'color' ? t : t + '-' + a\r\n  }\r\n}\r\n\r\n// Add sugar for fill and stroke\r\n;['fill', 'stroke'].forEach(function(m) {\r\n  var i, extension = {}\r\n\r\n  extension[m] = function(o) {\r\n    if (typeof o == 'undefined')\r\n      return this\r\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n      this.attr(m, o)\r\n\r\n    else\r\n      // set all attributes from sugar.fill and sugar.stroke list\r\n      for (i = sugar[m].length - 1; i >= 0; i--)\r\n        if (o[sugar[m][i]] != null)\r\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\r\n    return this\r\n  }\r\n\r\n  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, SVG.FX, {\r\n  // Map rotation to transform\r\n  rotate: function(d, cx, cy) {\r\n    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n  }\r\n  // Map skew to transform\r\n, skew: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ skew: x, cx: y, cy: cx }) :\r\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map scale to transform\r\n, scale: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ scale: x, cx: y, cy: cx }) :\r\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map translate to transform\r\n, translate: function(x, y) {\r\n    return this.transform({ x: x, y: y })\r\n  }\r\n  // Map flip to transform\r\n, flip: function(a, o) {\r\n    o = typeof a == 'number' ? a : o\r\n    return this.transform({ flip: a || 'both', offset: o })\r\n  }\r\n  // Map matrix to transform\r\n, matrix: function(m) {\r\n    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n  }\r\n  // Opacity\r\n, opacity: function(value) {\r\n    return this.attr('opacity', value)\r\n  }\r\n  // Relative move over x axis\r\n, dx: function(x) {\r\n    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n  }\r\n  // Relative move over y axis\r\n, dy: function(y) {\r\n    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n  }\r\n  // Relative move over x and y axes\r\n, dmove: function(x, y) {\r\n    return this.dx(x).dy(y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n  // Add x and y radius\r\n  radius: function(x, y) {\r\n    var type = (this._target || this).type;\r\n    return type == 'radial' || type == 'circle' ?\r\n      this.attr('r', new SVG.Number(x)) :\r\n      this.rx(x).ry(y == null ? x : y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Path, {\r\n  // Get path length\r\n  length: function() {\r\n    return this.node.getTotalLength()\r\n  }\r\n  // Get point at length\r\n, pointAt: function(length) {\r\n    return this.node.getPointAtLength(length)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n  // Set font\r\n  font: function(a, v) {\r\n    if (typeof a == 'object') {\r\n      for (v in a) this.font(v, a[v])\r\n    }\r\n\r\n    return a == 'leading' ?\r\n        this.leading(v) :\r\n      a == 'anchor' ?\r\n        this.attr('text-anchor', v) :\r\n      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n        this.attr('font-'+ a, v) :\r\n        this.attr(a, v)\r\n  }\r\n})\r\n\nSVG.Set = SVG.invent({\r\n  // Initialize\r\n  create: function(members) {\r\n    // Set initial state\r\n    Array.isArray(members) ? this.members = members : this.clear()\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add element to set\r\n    add: function() {\r\n      var i, il, elements = [].slice.call(arguments)\r\n\r\n      for (i = 0, il = elements.length; i < il; i++)\r\n        this.members.push(elements[i])\r\n\r\n      return this\r\n    }\r\n    // Remove element from set\r\n  , remove: function(element) {\r\n      var i = this.index(element)\r\n\r\n      // remove given child\r\n      if (i > -1)\r\n        this.members.splice(i, 1)\r\n\r\n      return this\r\n    }\r\n    // Iterate over all members\r\n  , each: function(block) {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        block.apply(this.members[i], [i, this.members])\r\n\r\n      return this\r\n    }\r\n    // Restore to defaults\r\n  , clear: function() {\r\n      // initialize store\r\n      this.members = []\r\n\r\n      return this\r\n    }\r\n    // Get the length of a set\r\n  , length: function() {\r\n      return this.members.length\r\n    }\r\n    // Checks if a given element is present in set\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // retuns index of given element in set\r\n  , index: function(element) {\r\n      return this.members.indexOf(element)\r\n    }\r\n    // Get member at given index\r\n  , get: function(i) {\r\n      return this.members[i]\r\n    }\r\n    // Get first member\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get last member\r\n  , last: function() {\r\n      return this.get(this.members.length - 1)\r\n    }\r\n    // Default value\r\n  , valueOf: function() {\r\n      return this.members\r\n    }\r\n    // Get the bounding box of all members included or empty box if set has no items\r\n  , bbox: function(){\r\n      // return an empty box of there are no members\r\n      if (this.members.length == 0)\r\n        return new SVG.RBox()\r\n\r\n      // get the first rbox and update the target bbox\r\n      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\r\n      this.each(function() {\r\n        // user rbox for correct position and visual representation\r\n        rbox = rbox.merge(this.rbox(this.doc()))\r\n      })\r\n\r\n      return rbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a new set\r\n    set: function(members) {\r\n      return new SVG.Set(members)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.FX.Set = SVG.invent({\r\n  // Initialize node\r\n  create: function(set) {\r\n    // store reference to set\r\n    this.set = set\r\n  }\r\n\r\n})\r\n\r\n// Alias methods\r\nSVG.Set.inherit = function() {\r\n  var m\r\n    , methods = []\r\n\r\n  // gather shape methods\r\n  for(var m in SVG.Shape.prototype)\r\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply shape aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n          this.members[i][method].apply(this.members[i], arguments)\r\n\r\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n    }\r\n  })\r\n\r\n  // clear methods for the next round\r\n  methods = []\r\n\r\n  // gather fx methods\r\n  for(var m in SVG.FX.prototype)\r\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply fx aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.FX.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\r\n      return this\r\n    }\r\n  })\r\n}\r\n\r\n\r\n\n\r\nSVG.extend(SVG.Element, {\r\n  // Store data values on svg nodes\r\n  data: function(a, v, r) {\r\n    if (typeof a == 'object') {\r\n      for (v in a)\r\n        this.data(v, a[v])\r\n\r\n    } else if (arguments.length < 2) {\r\n      try {\r\n        return JSON.parse(this.attr('data-' + a))\r\n      } catch(e) {\r\n        return this.attr('data-' + a)\r\n      }\r\n\r\n    } else {\r\n      this.attr(\r\n        'data-' + a\r\n      , v === null ?\r\n          null :\r\n        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n          v :\r\n          JSON.stringify(v)\r\n      )\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Remember arbitrary data\r\n  remember: function(k, v) {\r\n    // remember every item in an object individually\r\n    if (typeof arguments[0] == 'object')\r\n      for (var v in k)\r\n        this.remember(v, k[v])\r\n\r\n    // retrieve memory\r\n    else if (arguments.length == 1)\r\n      return this.memory()[k]\r\n\r\n    // store memory\r\n    else\r\n      this.memory()[k] = v\r\n\r\n    return this\r\n  }\r\n\r\n  // Erase a given memory\r\n, forget: function() {\r\n    if (arguments.length == 0)\r\n      this._memory = {}\r\n    else\r\n      for (var i = arguments.length - 1; i >= 0; i--)\r\n        delete this.memory()[arguments[i]]\r\n\r\n    return this\r\n  }\r\n\r\n  // Initialize or return local memory object\r\n, memory: function() {\r\n    return this._memory || (this._memory = {})\r\n  }\r\n\r\n})\n// Method for getting an element by id\r\nSVG.get = function(id) {\r\n  var node = document.getElementById(idFromReference(id) || id)\r\n  return SVG.adopt(node)\r\n}\r\n\r\n// Select elements by query string\r\nSVG.select = function(query, parent) {\r\n  return new SVG.Set(\r\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n      return SVG.adopt(node)\r\n    })\r\n  )\r\n}\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Scoped select method\r\n  select: function(query) {\r\n    return SVG.select(query, this.node)\r\n  }\r\n\r\n})\nfunction pathRegReplace(a, b, c, d) {\r\n  return c + d.replace(SVG.regex.dots, ' .')\r\n}\r\n\r\n// creates deep clone of array\r\nfunction array_clone(arr){\r\n  var clone = arr.slice(0)\r\n  for(var i = clone.length; i--;){\r\n    if(Array.isArray(clone[i])){\r\n      clone[i] = array_clone(clone[i])\r\n    }\r\n  }\r\n  return clone\r\n}\r\n\r\n// tests if a given element is instance of an object\r\nfunction is(el, obj){\r\n  return el instanceof obj\r\n}\r\n\r\n// tests if a given selector matches an element\r\nfunction matches(el, selector) {\r\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n}\r\n\r\n// Convert dash-separated-string to camelCase\r\nfunction camelCase(s) {\r\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n    return g.toUpperCase()\r\n  })\r\n}\r\n\r\n// Capitalize first letter of a string\r\nfunction capitalize(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\n// Ensure to six-based hex\r\nfunction fullHex(hex) {\r\n  return hex.length == 4 ?\r\n    [ '#',\r\n      hex.substring(1, 2), hex.substring(1, 2)\r\n    , hex.substring(2, 3), hex.substring(2, 3)\r\n    , hex.substring(3, 4), hex.substring(3, 4)\r\n    ].join('') : hex\r\n}\r\n\r\n// Component to hex value\r\nfunction compToHex(comp) {\r\n  var hex = comp.toString(16)\r\n  return hex.length == 1 ? '0' + hex : hex\r\n}\r\n\r\n// Calculate proportional width and height values when necessary\r\nfunction proportionalSize(element, width, height) {\r\n  if (width == null || height == null) {\r\n    var box = element.bbox()\r\n\r\n    if (width == null)\r\n      width = box.width / box.height * height\r\n    else if (height == null)\r\n      height = box.height / box.width * width\r\n  }\r\n\r\n  return {\r\n    width:  width\r\n  , height: height\r\n  }\r\n}\r\n\r\n// Delta transform point\r\nfunction deltaTransformPoint(matrix, x, y) {\r\n  return {\r\n    x: x * matrix.a + y * matrix.c + 0\r\n  , y: x * matrix.b + y * matrix.d + 0\r\n  }\r\n}\r\n\r\n// Map matrix array to object\r\nfunction arrayToMatrix(a) {\r\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n}\r\n\r\n// Parse matrix if required\r\nfunction parseMatrix(matrix) {\r\n  if (!(matrix instanceof SVG.Matrix))\r\n    matrix = new SVG.Matrix(matrix)\r\n\r\n  return matrix\r\n}\r\n\r\n// Add centre point to transform object\r\nfunction ensureCentre(o, target) {\r\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n}\r\n\r\n// PathArray Helpers\r\nfunction arrayToString(a) {\r\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n    s += a[i][0]\r\n\r\n    if (a[i][1] != null) {\r\n      s += a[i][1]\r\n\r\n      if (a[i][2] != null) {\r\n        s += ' '\r\n        s += a[i][2]\r\n\r\n        if (a[i][3] != null) {\r\n          s += ' '\r\n          s += a[i][3]\r\n          s += ' '\r\n          s += a[i][4]\r\n\r\n          if (a[i][5] != null) {\r\n            s += ' '\r\n            s += a[i][5]\r\n            s += ' '\r\n            s += a[i][6]\r\n\r\n            if (a[i][7] != null) {\r\n              s += ' '\r\n              s += a[i][7]\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return s + ' '\r\n}\r\n\r\n// Deep new id assignment\r\nfunction assignNewId(node) {\r\n  // do the same for SVG child nodes as well\r\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n    if (node.childNodes[i] instanceof window.SVGElement)\r\n      assignNewId(node.childNodes[i])\r\n\r\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n}\r\n\r\n// Add more bounding box properties\r\nfunction fullBox(b) {\r\n  if (b.x == null) {\r\n    b.x      = 0\r\n    b.y      = 0\r\n    b.width  = 0\r\n    b.height = 0\r\n  }\r\n\r\n  b.w  = b.width\r\n  b.h  = b.height\r\n  b.x2 = b.x + b.width\r\n  b.y2 = b.y + b.height\r\n  b.cx = b.x + b.width / 2\r\n  b.cy = b.y + b.height / 2\r\n\r\n  return b\r\n}\r\n\r\n// Get id from reference string\r\nfunction idFromReference(url) {\r\n  var m = url.toString().match(SVG.regex.reference)\r\n\r\n  if (m) return m[1]\r\n}\r\n\r\n// Create matrix array for looping\r\nvar abcdef = 'abcdef'.split('')\n// Add CustomEvent to IE9 and IE10\r\nif (typeof window.CustomEvent !== 'function') {\r\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n  var CustomEvent = function(event, options) {\r\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n    var e = document.createEvent('CustomEvent')\r\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n    return e\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype\r\n\r\n  window.CustomEvent = CustomEvent\r\n}\r\n\r\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n(function(w) {\r\n  var lastTime = 0\r\n  var vendors = ['moz', 'webkit']\r\n\r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n  }\r\n\r\n  w.requestAnimationFrame = w.requestAnimationFrame ||\r\n    function(callback) {\r\n      var currTime = new Date().getTime()\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n\r\n      var id = w.setTimeout(function() {\r\n        callback(currTime + timeToCall)\r\n      }, timeToCall)\r\n\r\n      lastTime = currTime + timeToCall\r\n      return id\r\n    }\r\n\r\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\r\n}(window))\r\n\r\nreturn SVG\r\n\r\n}));\r\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(1);\n\nvar _svg = __webpack_require__(2);\n\nvar SVG = _interopRequireWildcard(_svg);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    // code...\n\n    var svg = SVG(\"game\").size(300, 300);\n    var rect = svg.rect(100, 100).attr({ fill: '#f06' });\n});\n\n// other work here...\n\n//let draw = svg(\"game-board-svg\");\n\n\n// // create a game instance\n// const gameElement = document.getElementById(\"game\");\n// const game = new Game(gameElement, gameElement.clientWidth, gameElement.clientHeight);\n\n// (function gameLoop() {\n//     game.render();\n//     requestAnimationFrame(gameLoop);\n// })();\n\n// import Game from \"./partials/Game\";\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(5)();\n// imports\n\n\n// module\nexports.push([module.i, \"a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:\\\"\\\";content:none}table{border-collapse:collapse;border-spacing:0}@font-face{font-family:Silkscreen Web;src:url(\" + __webpack_require__(0) + \");src:url(\" + __webpack_require__(0) + \"?#iefix) format(\\\"embedded-opentype\\\"),url(\" + __webpack_require__(8) + \") format(\\\"woff\\\"),url(\" + __webpack_require__(7) + \") format(\\\"truetype\\\"),url(\" + __webpack_require__(6) + \"#silkscreennormal) format(\\\"svg\\\");font-weight:400;font-style:normal}html{font-size:16px}body{align-items:center;display:flex;font-family:Silkscreen Web,monotype;height:100vh;justify-content:center;width:100%}h1{font-size:2.5rem;margin-bottom:1rem;text-align:center}.game-board svg{background:#353535;color:#fff;stroke:#fff;fill:#fff}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"public/fonts/slkscr-webfont.svg\";\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"public/fonts/slkscr-webfont.ttf\";\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"public/fonts/slkscr-webfont.woff\";\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b40b89f0cd5d9ec5565b","module.exports = __webpack_public_path__ + \"public/fonts/slkscr-webfont.eot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/fonts/slkscr-webfont.eot\n// module id = 0\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js!./game.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!./game.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!./game.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/styles/game.css\n// module id = 1\n// module chunks = 0","/*!\n* svg.js - A lightweight library for manipulating and animating SVG.\n* @version 2.6.4\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Wed Feb 07 2018 22:59:25 GMT+0100 (Mitteleuropische Zeit)\n*/;\n(function(root, factory) {\r\n  /* istanbul ignore next */\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function(){\r\n      return factory(root, root.document)\r\n    })\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n  } else {\r\n    root.SVG = factory(root, root.document)\r\n  }\r\n}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\r\n// The main wrapping element\r\nvar SVG = this.SVG = function(element) {\r\n  if (SVG.supported) {\r\n    element = new SVG.Doc(element)\r\n\r\n    if(!SVG.parser.draw)\r\n      SVG.prepare()\r\n\r\n    return element\r\n  }\r\n}\r\n\r\n// Default namespaces\r\nSVG.ns    = 'http://www.w3.org/2000/svg'\r\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\nSVG.xlink = 'http://www.w3.org/1999/xlink'\r\nSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\r\n// Svg support test\r\nSVG.supported = (function() {\r\n  return !! document.createElementNS &&\r\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n})()\r\n\r\n// Don't bother to continue if SVG is not supported\r\nif (!SVG.supported) return false\r\n\r\n// Element id sequence\r\nSVG.did  = 1000\r\n\r\n// Get next named element id\r\nSVG.eid = function(name) {\r\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n}\r\n\r\n// Method for element creation\r\nSVG.create = function(name) {\r\n  // create element\r\n  var element = document.createElementNS(this.ns, name)\r\n\r\n  // apply unique id\r\n  element.setAttribute('id', this.eid(name))\r\n\r\n  return element\r\n}\r\n\r\n// Method for extending objects\r\nSVG.extend = function() {\r\n  var modules, methods, key, i\r\n\r\n  // Get list of modules\r\n  modules = [].slice.call(arguments)\r\n\r\n  // Get object with extensions\r\n  methods = modules.pop()\r\n\r\n  for (i = modules.length - 1; i >= 0; i--)\r\n    if (modules[i])\r\n      for (key in methods)\r\n        modules[i].prototype[key] = methods[key]\r\n\r\n  // Make sure SVG.Set inherits any newly added methods\r\n  if (SVG.Set && SVG.Set.inherit)\r\n    SVG.Set.inherit()\r\n}\r\n\r\n// Invent new element\r\nSVG.invent = function(config) {\r\n  // Create element initializer\r\n  var initializer = typeof config.create == 'function' ?\r\n    config.create :\r\n    function() {\r\n      this.constructor.call(this, SVG.create(config.create))\r\n    }\r\n\r\n  // Inherit prototype\r\n  if (config.inherit)\r\n    initializer.prototype = new config.inherit\r\n\r\n  // Extend with methods\r\n  if (config.extend)\r\n    SVG.extend(initializer, config.extend)\r\n\r\n  // Attach construct method to parent\r\n  if (config.construct)\r\n    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\r\n  return initializer\r\n}\r\n\r\n// Adopt existing svg elements\r\nSVG.adopt = function(node) {\r\n  // check for presence of node\r\n  if (!node) return null\r\n\r\n  // make sure a node isn't already adopted\r\n  if (node.instance) return node.instance\r\n\r\n  // initialize variables\r\n  var element\r\n\r\n  // adopt with element-specific settings\r\n  if (node.nodeName == 'svg')\r\n    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n  else if (node.nodeName == 'linearGradient')\r\n    element = new SVG.Gradient('linear')\r\n  else if (node.nodeName == 'radialGradient')\r\n    element = new SVG.Gradient('radial')\r\n  else if (SVG[capitalize(node.nodeName)])\r\n    element = new SVG[capitalize(node.nodeName)]\r\n  else\r\n    element = new SVG.Element(node)\r\n\r\n  // ensure references\r\n  element.type  = node.nodeName\r\n  element.node  = node\r\n  node.instance = element\r\n\r\n  // SVG.Class specific preparations\r\n  if (element instanceof SVG.Doc)\r\n    element.namespace().defs()\r\n\r\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\r\n  return element\r\n}\r\n\r\n// Initialize parsing element\r\nSVG.prepare = function() {\r\n  // Select document body and create invisible svg element\r\n  var body = document.getElementsByTagName('body')[0]\r\n    , draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\r\n  // Create parser object\r\n  SVG.parser = {\r\n    body: body || document.documentElement\r\n  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node\r\n  , poly: draw.polyline().node\r\n  , path: draw.path().node\r\n  , native: SVG.create('svg')\r\n  }\r\n}\r\n\r\nSVG.parser = {\r\n  native: SVG.create('svg')\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n  if(!SVG.parser.draw)\r\n    SVG.prepare()\r\n}, false)\r\n\n// Storage for regular expressions\r\nSVG.regex = {\r\n  // Parse unit value\r\n  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\r\n  // Parse hex value\r\n, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\r\n  // Parse rgb value\r\n, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\r\n  // Parse reference id\r\n, reference:        /#([a-z0-9\\-_]+)/i\r\n\r\n  // splits a transformation chain\r\n, transforms:       /\\)\\s*,?\\s*/\r\n\r\n  // Whitespace\r\n, whitespace:       /\\s/g\r\n\r\n  // Test hex value\r\n, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\r\n  // Test rgb value\r\n, isRgb:            /^rgb\\(/\r\n\r\n  // Test css declaration\r\n, isCss:            /[^:]+:[^;]+;?/\r\n\r\n  // Test for blank string\r\n, isBlank:          /^(\\s+)?$/\r\n\r\n  // Test for numeric string\r\n, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\r\n  // Test for percent value\r\n, isPercent:        /^-?[\\d\\.]+%$/\r\n\r\n  // Test for image url\r\n, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\r\n  // split at whitespace and comma\r\n, delimiter:        /[\\s,]+/\r\n\r\n  // The following regex are used to parse the d attribute of a path\r\n\r\n  // Matches all hyphens which are not after an exponent\r\n, hyphen:           /([^e])\\-/gi\r\n\r\n  // Replaces and tests for all path letters\r\n, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\r\n  // yes we need this one, too\r\n, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\r\n  // matches 0.154.23.45\r\n, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\r\n  // matches .\r\n, dots:             /\\./g\r\n}\r\n\nSVG.utils = {\r\n  // Map function\r\n  map: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      result.push(block(array[i]))\r\n\r\n    return result\r\n  }\r\n\r\n  // Filter function\r\n, filter: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      if (block(array[i]))\r\n        result.push(array[i])\r\n\r\n    return result\r\n  }\r\n\r\n  // Degrees to radians\r\n, radians: function(d) {\r\n    return d % 360 * Math.PI / 180\r\n  }\r\n\r\n  // Radians to degrees\r\n, degrees: function(r) {\r\n    return r * 180 / Math.PI % 360\r\n  }\r\n\r\n, filterSVGElements: function(nodes) {\r\n    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n  }\r\n\r\n}\n\r\nSVG.defaults = {\r\n  // Default attribute values\r\n  attrs: {\r\n    // fill and stroke\r\n    'fill-opacity':     1\r\n  , 'stroke-opacity':   1\r\n  , 'stroke-width':     0\r\n  , 'stroke-linejoin':  'miter'\r\n  , 'stroke-linecap':   'butt'\r\n  , fill:               '#000000'\r\n  , stroke:             '#000000'\r\n  , opacity:            1\r\n    // position\r\n  , x:                  0\r\n  , y:                  0\r\n  , cx:                 0\r\n  , cy:                 0\r\n    // size\r\n  , width:              0\r\n  , height:             0\r\n    // radius\r\n  , r:                  0\r\n  , rx:                 0\r\n  , ry:                 0\r\n    // gradient\r\n  , offset:             0\r\n  , 'stop-opacity':     1\r\n  , 'stop-color':       '#000000'\r\n    // text\r\n  , 'font-size':        16\r\n  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n  , 'text-anchor':      'start'\r\n  }\r\n\r\n}\n// Module for color convertions\r\nSVG.Color = function(color) {\r\n  var match\r\n\r\n  // initialize defaults\r\n  this.r = 0\r\n  this.g = 0\r\n  this.b = 0\r\n\r\n  if(!color) return\r\n\r\n  // parse color\r\n  if (typeof color === 'string') {\r\n    if (SVG.regex.isRgb.test(color)) {\r\n      // get rgb values\r\n      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1])\r\n      this.g = parseInt(match[2])\r\n      this.b = parseInt(match[3])\r\n\r\n    } else if (SVG.regex.isHex.test(color)) {\r\n      // get hex values\r\n      match = SVG.regex.hex.exec(fullHex(color))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1], 16)\r\n      this.g = parseInt(match[2], 16)\r\n      this.b = parseInt(match[3], 16)\r\n\r\n    }\r\n\r\n  } else if (typeof color === 'object') {\r\n    this.r = color.r\r\n    this.g = color.g\r\n    this.b = color.b\r\n\r\n  }\r\n\r\n}\r\n\r\nSVG.extend(SVG.Color, {\r\n  // Default to hex conversion\r\n  toString: function() {\r\n    return this.toHex()\r\n  }\r\n  // Build hex value\r\n, toHex: function() {\r\n    return '#'\r\n      + compToHex(this.r)\r\n      + compToHex(this.g)\r\n      + compToHex(this.b)\r\n  }\r\n  // Build rgb value\r\n, toRgb: function() {\r\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n  }\r\n  // Calculate true brightness\r\n, brightness: function() {\r\n    return (this.r / 255 * 0.30)\r\n         + (this.g / 255 * 0.59)\r\n         + (this.b / 255 * 0.11)\r\n  }\r\n  // Make color morphable\r\n, morph: function(color) {\r\n    this.destination = new SVG.Color(color)\r\n\r\n    return this\r\n  }\r\n  // Get morphed color at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // normalise pos\r\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\r\n    // generate morphed color\r\n    return new SVG.Color({\r\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n    })\r\n  }\r\n\r\n})\r\n\r\n// Testers\r\n\r\n// Test if given value is a color string\r\nSVG.Color.test = function(color) {\r\n  color += ''\r\n  return SVG.regex.isHex.test(color)\r\n      || SVG.regex.isRgb.test(color)\r\n}\r\n\r\n// Test if given value is a rgb object\r\nSVG.Color.isRgb = function(color) {\r\n  return color && typeof color.r == 'number'\r\n               && typeof color.g == 'number'\r\n               && typeof color.b == 'number'\r\n}\r\n\r\n// Test if given value is a color\r\nSVG.Color.isColor = function(color) {\r\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n}\n// Module for array conversion\r\nSVG.Array = function(array, fallback) {\r\n  array = (array || []).valueOf()\r\n\r\n  // if array is empty and fallback is provided, use fallback\r\n  if (array.length == 0 && fallback)\r\n    array = fallback.valueOf()\r\n\r\n  // parse array\r\n  this.value = this.parse(array)\r\n}\r\n\r\nSVG.extend(SVG.Array, {\r\n  // Make array morphable\r\n  morph: function(array) {\r\n    this.destination = this.parse(array)\r\n\r\n    // normalize length of arrays\r\n    if (this.value.length != this.destination.length) {\r\n      var lastValue       = this.value[this.value.length - 1]\r\n        , lastDestination = this.destination[this.destination.length - 1]\r\n\r\n      while(this.value.length > this.destination.length)\r\n        this.destination.push(lastDestination)\r\n      while(this.value.length < this.destination.length)\r\n        this.value.push(lastValue)\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Clean up any duplicate points\r\n, settle: function() {\r\n    // find all unique values\r\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n      if (seen.indexOf(this.value[i]) == -1)\r\n        seen.push(this.value[i])\r\n\r\n    // set new value\r\n    return this.value = seen\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed array\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\r\n    return new SVG.Array(array)\r\n  }\r\n  // Convert array to string\r\n, toString: function() {\r\n    return this.value.join(' ')\r\n  }\r\n  // Real value\r\n, valueOf: function() {\r\n    return this.value\r\n  }\r\n  // Parse whitespace separated string\r\n, parse: function(array) {\r\n    array = array.valueOf()\r\n\r\n    // if already is an array, no need to parse it\r\n    if (Array.isArray(array)) return array\r\n\r\n    return this.split(array)\r\n  }\r\n  // Strip unnecessary whitespace\r\n, split: function(string) {\r\n    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n  }\r\n  // Reverse array\r\n, reverse: function() {\r\n    this.value.reverse()\r\n\r\n    return this\r\n  }\r\n, clone: function() {\r\n    var clone = new this.constructor()\r\n    clone.value = array_clone(this.value)\r\n    return clone\r\n  }\r\n})\n// Poly points array\r\nSVG.PointArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [[0,0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PointArray.prototype = new SVG.Array\r\nSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\r\nSVG.extend(SVG.PointArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    // convert to a poly point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i].join(','))\r\n\r\n    return array.join(' ')\r\n  }\r\n  // Convert array to line object\r\n, toLine: function() {\r\n    return {\r\n      x1: this.value[0][0]\r\n    , y1: this.value[0][1]\r\n    , x2: this.value[1][0]\r\n    , y2: this.value[1][1]\r\n    }\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push([\r\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n      ])\r\n\r\n    return new SVG.PointArray(array)\r\n  }\r\n  // Parse point string and flat array\r\n, parse: function(array) {\r\n    var points = []\r\n\r\n    array = array.valueOf()\r\n\r\n    // if it is an array\r\n    if (Array.isArray(array)) {\r\n      // and it is not flat, there is no need to parse it\r\n      if(Array.isArray(array[0])) {\r\n        return array\r\n      }\r\n    } else { // Else, it is considered as a string\r\n      // parse points\r\n      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n    }\r\n\r\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n    if (array.length % 2 !== 0) array.pop()\r\n\r\n    // wrap points in two-tuples and parse points as floats\r\n    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n      points.push([ array[i], array[i+1] ])\r\n\r\n    return points\r\n  }\r\n  // Move point string\r\n, move: function(x, y) {\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    // move every point\r\n    if (!isNaN(x) && !isNaN(y))\r\n      for (var i = this.value.length - 1; i >= 0; i--)\r\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\r\n    return this\r\n  }\r\n  // Resize poly string\r\n, size: function(width, height) {\r\n    var i, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get bounding box of points\r\n, bbox: function() {\r\n    SVG.parser.poly.setAttribute('points', this.toString())\r\n\r\n    return SVG.parser.poly.getBBox()\r\n  }\r\n})\r\n\nvar pathHandlers = {\r\n  M: function(c, p, p0) {\r\n    p.x = p0.x = c[0]\r\n    p.y = p0.y = c[1]\r\n\r\n    return ['M', p.x, p.y]\r\n  },\r\n  L: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['L', c[0], c[1]]\r\n  },\r\n  H: function(c, p) {\r\n    p.x = c[0]\r\n    return ['H', c[0]]\r\n  },\r\n  V: function(c, p) {\r\n    p.y = c[0]\r\n    return ['V', c[0]]\r\n  },\r\n  C: function(c, p) {\r\n    p.x = c[4]\r\n    p.y = c[5]\r\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\r\n  },\r\n  S: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['S', c[0], c[1], c[2], c[3]]\r\n  },\r\n  Q: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['Q', c[0], c[1], c[2], c[3]]\r\n  },\r\n  T: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['T', c[0], c[1]]\r\n  },\r\n  Z: function(c, p, p0) {\r\n    p.x = p0.x\r\n    p.y = p0.y\r\n    return ['Z']\r\n  },\r\n  A: function(c, p) {\r\n    p.x = c[5]\r\n    p.y = c[6]\r\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\r\n  }\r\n}\r\n\r\nvar mlhvqtcsa = 'mlhvqtcsaz'.split('')\r\n\r\nfor(var i = 0, il = mlhvqtcsa.length; i < il; ++i){\r\n  pathHandlers[mlhvqtcsa[i]] = (function(i){\r\n    return function(c, p, p0) {\r\n      if(i == 'H') c[0] = c[0] + p.x\r\n      else if(i == 'V') c[0] = c[0] + p.y\r\n      else if(i == 'A'){\r\n        c[5] = c[5] + p.x,\r\n        c[6] = c[6] + p.y\r\n      }\r\n      else\r\n        for(var j = 0, jl = c.length; j < jl; ++j) {\r\n          c[j] = c[j] + (j%2 ? p.y : p.x)\r\n        }\r\n\r\n      return pathHandlers[i](c, p, p0)\r\n    }\r\n  })(mlhvqtcsa[i].toUpperCase())\r\n}\r\n\r\n// Path points array\r\nSVG.PathArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PathArray.prototype = new SVG.Array\r\nSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    return arrayToString(this.value)\r\n  }\r\n  // Move path string\r\n, move: function(x, y) {\r\n    // get bounding box of current situation\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    if (!isNaN(x) && !isNaN(y)) {\r\n      // move every point\r\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n        l = this.value[i][0]\r\n\r\n        if (l == 'M' || l == 'L' || l == 'T')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n\r\n        } else if (l == 'H')  {\r\n          this.value[i][1] += x\r\n\r\n        } else if (l == 'V')  {\r\n          this.value[i][1] += y\r\n\r\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n          this.value[i][3] += x\r\n          this.value[i][4] += y\r\n\r\n          if (l == 'C')  {\r\n            this.value[i][5] += x\r\n            this.value[i][6] += y\r\n          }\r\n\r\n        } else if (l == 'A')  {\r\n          this.value[i][6] += x\r\n          this.value[i][7] += y\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Resize path string\r\n, size: function(width, height) {\r\n    // get bounding box of current situation\r\n    var i, l, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      l = this.value[i][0]\r\n\r\n      if (l == 'M' || l == 'L' || l == 'T')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'H')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\r\n      } else if (l == 'V')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\r\n        if (l == 'C')  {\r\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n        }\r\n\r\n      } else if (l == 'A')  {\r\n        // resize radii\r\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\r\n        // move position values\r\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n      }\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Test if the passed path array use the same path data commands as this path array\r\n, equalCommands: function(pathArray) {\r\n    var i, il, equalCommands\r\n\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    equalCommands = this.value.length === pathArray.value.length\r\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n    }\r\n\r\n    return equalCommands\r\n  }\r\n  // Make path array morphable\r\n, morph: function(pathArray) {\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    if(this.equalCommands(pathArray)) {\r\n      this.destination = pathArray\r\n    } else {\r\n      this.destination = null\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get morphed path array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    var sourceArray = this.value\r\n      , destinationArray = this.destination.value\r\n      , array = [], pathArray = new SVG.PathArray()\r\n      , i, il, j, jl\r\n\r\n    // Animate has specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n      array[i] = [sourceArray[i][0]]\r\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n      }\r\n      // For the two flags of the elliptical arc command, the SVG spec say:\r\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n      // Elliptical arc command as an array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      if(array[i][0] === 'A') {\r\n        array[i][4] = +(array[i][4] != 0)\r\n        array[i][5] = +(array[i][5] != 0)\r\n      }\r\n    }\r\n\r\n    // Directly modify the value of a path array, this is done this way for performance\r\n    pathArray.value = array\r\n    return pathArray\r\n  }\r\n  // Absolutize and parse path to array\r\n, parse: function(array) {\r\n    // if it's already a patharray, no need to parse it\r\n    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\r\n    // prepare for parsing\r\n    var i, x0, y0, s, seg, arr\r\n      , x = 0\r\n      , y = 0\r\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7, 'Z':0 }\r\n\r\n    if(typeof array == 'string'){\r\n\r\n      array = array\r\n        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n        .trim()                                 // trim\r\n        .split(SVG.regex.delimiter)   // split into array\r\n\r\n    }else{\r\n      array = array.reduce(function(prev, curr){\r\n        return [].concat.call(prev, curr)\r\n      }, [])\r\n    }\r\n\r\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n    var arr = []\r\n      , p = new SVG.Point()\r\n      , p0 = new SVG.Point()\r\n      , index = 0\r\n      , len = array.length\r\n\r\n    do{\r\n      // Test if we have a path letter\r\n      if(SVG.regex.isPathLetter.test(array[index])){\r\n        s = array[index]\r\n        ++index\r\n      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n      }else if(s == 'M'){\r\n        s = 'L'\r\n      }else if(s == 'm'){\r\n        s = 'l'\r\n      }\r\n\r\n      arr.push(pathHandlers[s].call(null,\r\n          array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),\r\n          p, p0\r\n        )\r\n      )\r\n\r\n    }while(len > index)\r\n\r\n    return arr\r\n\r\n  }\r\n  // Get bounding box of path\r\n, bbox: function() {\r\n    SVG.parser.path.setAttribute('d', this.toString())\r\n\r\n    return SVG.parser.path.getBBox()\r\n  }\r\n\r\n})\r\n\n// Module for unit convertions\r\nSVG.Number = SVG.invent({\r\n  // Initialize\r\n  create: function(value, unit) {\r\n    // initialize defaults\r\n    this.value = 0\r\n    this.unit  = unit || ''\r\n\r\n    // parse value\r\n    if (typeof value === 'number') {\r\n      // ensure a valid numeric value\r\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\r\n    } else if (typeof value === 'string') {\r\n      unit = value.match(SVG.regex.numberAndUnit)\r\n\r\n      if (unit) {\r\n        // make value numeric\r\n        this.value = parseFloat(unit[1])\r\n\r\n        // normalize\r\n        if (unit[5] == '%')\r\n          this.value /= 100\r\n        else if (unit[5] == 's')\r\n          this.value *= 1000\r\n\r\n        // store unit\r\n        this.unit = unit[5]\r\n      }\r\n\r\n    } else {\r\n      if (value instanceof SVG.Number) {\r\n        this.value = value.valueOf()\r\n        this.unit  = value.unit\r\n      }\r\n    }\r\n\r\n  }\r\n  // Add methods\r\n, extend: {\r\n    // Stringalize\r\n    toString: function() {\r\n      return (\r\n        this.unit == '%' ?\r\n          ~~(this.value * 1e8) / 1e6:\r\n        this.unit == 's' ?\r\n          this.value / 1e3 :\r\n          this.value\r\n      ) + this.unit\r\n    }\r\n  , toJSON: function() {\r\n      return this.toString()\r\n    }\r\n  , // Convert to primitive\r\n    valueOf: function() {\r\n      return this.value\r\n    }\r\n    // Add number\r\n  , plus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this + number, this.unit || number.unit)\r\n    }\r\n    // Subtract number\r\n  , minus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this - number, this.unit || number.unit)\r\n    }\r\n    // Multiply number\r\n  , times: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this * number, this.unit || number.unit)\r\n    }\r\n    // Divide number\r\n  , divide: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this / number, this.unit || number.unit)\r\n    }\r\n    // Convert to different unit\r\n  , to: function(unit) {\r\n      var number = new SVG.Number(this)\r\n\r\n      if (typeof unit === 'string')\r\n        number.unit = unit\r\n\r\n      return number\r\n    }\r\n    // Make number morphable\r\n  , morph: function(number) {\r\n      this.destination = new SVG.Number(number)\r\n\r\n      if(number.relative) {\r\n        this.destination.value += this.value\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Get morphed number at given position\r\n  , at: function(pos) {\r\n      // Make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // Generate new morphed number\r\n      return new SVG.Number(this.destination)\r\n          .minus(this)\r\n          .times(pos)\r\n          .plus(this)\r\n    }\r\n\r\n  }\r\n})\r\n\n\r\nSVG.Element = SVG.invent({\r\n  // Initialize node\r\n  create: function(node) {\r\n    // make stroke value accessible dynamically\r\n    this._stroke = SVG.defaults.attrs.stroke\r\n    this._event = null\r\n\r\n    // initialize data object\r\n    this.dom = {}\r\n\r\n    // create circular reference\r\n    if (this.node = node) {\r\n      this.type = node.nodeName\r\n      this.node.instance = this\r\n\r\n      // store current attribute value\r\n      this._stroke = node.getAttribute('stroke') || this._stroke\r\n    }\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return this.attr('y', y)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n    }\r\n    // Move element to given x and y values\r\n  , move: function(x, y) {\r\n      return this.x(x).y(y)\r\n    }\r\n    // Move element by its center\r\n  , center: function(x, y) {\r\n      return this.cx(x).cy(y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return this.attr('width', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('height', height)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .width(new SVG.Number(p.width))\r\n        .height(new SVG.Number(p.height))\r\n    }\r\n    // Clone element\r\n  , clone: function(parent, withData) {\r\n      // write dom data to the dom so the clone can pickup the data\r\n      this.writeDataToDom()\r\n\r\n      // clone element and assign new id\r\n      var clone = assignNewId(this.node.cloneNode(true))\r\n\r\n      // insert the clone in the given parent or after myself\r\n      if(parent) parent.add(clone)\r\n      else this.after(clone)\r\n\r\n      return clone\r\n    }\r\n    // Remove element\r\n  , remove: function() {\r\n      if (this.parent())\r\n        this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n    // Replace element\r\n  , replace: function(element) {\r\n      this.after(element).remove()\r\n\r\n      return element\r\n    }\r\n    // Add element to given container and return self\r\n  , addTo: function(parent) {\r\n      return parent.put(this)\r\n    }\r\n    // Add element to given container and return container\r\n  , putIn: function(parent) {\r\n      return parent.add(this)\r\n    }\r\n    // Get / set id\r\n  , id: function(id) {\r\n      return this.attr('id', id)\r\n    }\r\n    // Checks whether the given point inside the bounding box of the element\r\n  , inside: function(x, y) {\r\n      var box = this.bbox()\r\n\r\n      return x > box.x\r\n          && y > box.y\r\n          && x < box.x + box.width\r\n          && y < box.y + box.height\r\n    }\r\n    // Show element\r\n  , show: function() {\r\n      return this.style('display', '')\r\n    }\r\n    // Hide element\r\n  , hide: function() {\r\n      return this.style('display', 'none')\r\n    }\r\n    // Is element visible?\r\n  , visible: function() {\r\n      return this.style('display') != 'none'\r\n    }\r\n    // Return id on string conversion\r\n  , toString: function() {\r\n      return this.attr('id')\r\n    }\r\n    // Return array of classes on the node\r\n  , classes: function() {\r\n      var attr = this.attr('class')\r\n\r\n      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n    }\r\n    // Return true if class exists on the node, false otherwise\r\n  , hasClass: function(name) {\r\n      return this.classes().indexOf(name) != -1\r\n    }\r\n    // Add class to the node\r\n  , addClass: function(name) {\r\n      if (!this.hasClass(name)) {\r\n        var array = this.classes()\r\n        array.push(name)\r\n        this.attr('class', array.join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove class from the node\r\n  , removeClass: function(name) {\r\n      if (this.hasClass(name)) {\r\n        this.attr('class', this.classes().filter(function(c) {\r\n          return c != name\r\n        }).join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Toggle the presence of a class on the node\r\n  , toggleClass: function(name) {\r\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n    }\r\n    // Get referenced element form attribute value\r\n  , reference: function(attr) {\r\n      return SVG.get(this.attr(attr))\r\n    }\r\n    // Returns the parent element instance\r\n  , parent: function(type) {\r\n      var parent = this\r\n\r\n      // check for parent\r\n      if(!parent.node.parentNode) return null\r\n\r\n      // get parent element\r\n      parent = SVG.adopt(parent.node.parentNode)\r\n\r\n      if(!type) return parent\r\n\r\n      // loop trough ancestors if type is given\r\n      while(parent && parent.node instanceof window.SVGElement){\r\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n        if(parent.node.parentNode.nodeName == '#document') return null // #720\r\n        parent = SVG.adopt(parent.node.parentNode)\r\n      }\r\n    }\r\n    // Get parent document\r\n  , doc: function() {\r\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n    }\r\n    // return array of all ancestors of given type up to the root svg\r\n  , parents: function(type) {\r\n      var parents = [], parent = this\r\n\r\n      do{\r\n        parent = parent.parent(type)\r\n        if(!parent || !parent.node) break\r\n\r\n        parents.push(parent)\r\n      } while(parent.parent)\r\n\r\n      return parents\r\n    }\r\n    // matches the element vs a css selector\r\n  , matches: function(selector){\r\n      return matches(this.node, selector)\r\n    }\r\n    // Returns the svg node to call native svg methods on it\r\n  , native: function() {\r\n      return this.node\r\n    }\r\n    // Import raw svg\r\n  , svg: function(svg) {\r\n      // create temporary holder\r\n      var well = document.createElement('svg')\r\n\r\n      // act as a setter if svg is given\r\n      if (svg && this instanceof SVG.Parent) {\r\n        // dump raw svg\r\n        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\r\n        // transplant nodes\r\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n          this.node.appendChild(well.firstChild.firstChild)\r\n\r\n      // otherwise act as a getter\r\n      } else {\r\n        // create a wrapping svg element in case of partial content\r\n        well.appendChild(svg = document.createElement('svg'))\r\n\r\n        // write svgjs data to the dom\r\n        this.writeDataToDom()\r\n\r\n        // insert a copy of this node\r\n        svg.appendChild(this.node.cloneNode(true))\r\n\r\n        // return target element\r\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n      }\r\n\r\n      return this\r\n    }\r\n  // write svgjs data to the dom\r\n  , writeDataToDom: function() {\r\n\r\n      // dump variables recursively\r\n      if(this.each || this.lines){\r\n        var fn = this.each ? this : this.lines();\r\n        fn.each(function(){\r\n          this.writeDataToDom()\r\n        })\r\n      }\r\n\r\n      // remove previously set data\r\n      this.node.removeAttribute('svgjs:data')\r\n\r\n      if(Object.keys(this.dom).length)\r\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\r\n      return this\r\n    }\r\n  // set given data to the elements data property\r\n  , setData: function(o){\r\n      this.dom = o\r\n      return this\r\n    }\r\n  , is: function(obj){\r\n      return is(this, obj)\r\n    }\r\n  }\r\n})\r\n\nSVG.easing = {\r\n  '-': function(pos){return pos}\r\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n}\r\n\r\nSVG.morph = function(pos){\r\n  return function(from, to) {\r\n    return new SVG.MorphObj(from, to).at(pos)\r\n  }\r\n}\r\n\r\nSVG.Situation = SVG.invent({\r\n\r\n  create: function(o){\r\n    this.init = false\r\n    this.reversed = false\r\n    this.reversing = false\r\n\r\n    this.duration = new SVG.Number(o.duration).valueOf()\r\n    this.delay = new SVG.Number(o.delay).valueOf()\r\n\r\n    this.start = +new Date() + this.delay\r\n    this.finish = this.start + this.duration\r\n    this.ease = o.ease\r\n\r\n    // this.loop is incremented from 0 to this.loops\r\n    // it is also incremented when in an infinite loop (when this.loops is true)\r\n    this.loop = 0\r\n    this.loops = false\r\n\r\n    this.animations = {\r\n      // functionToCall: [list of morphable objects]\r\n      // e.g. move: [SVG.Number, SVG.Number]\r\n    }\r\n\r\n    this.attrs = {\r\n      // holds all attributes which are not represented from a function svg.js provides\r\n      // e.g. someAttr: SVG.Number\r\n    }\r\n\r\n    this.styles = {\r\n      // holds all styles which should be animated\r\n      // e.g. fill-color: SVG.Color\r\n    }\r\n\r\n    this.transforms = [\r\n      // holds all transformations as transformation objects\r\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n    ]\r\n\r\n    this.once = {\r\n      // functions to fire at a specific position\r\n      // e.g. \"0.5\": function foo(){}\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\n\r\nSVG.FX = SVG.invent({\r\n\r\n  create: function(element) {\r\n    this._target = element\r\n    this.situations = []\r\n    this.active = false\r\n    this.situation = null\r\n    this.paused = false\r\n    this.lastPos = 0\r\n    this.pos = 0\r\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n    this.absPos = 0\r\n    this._speed = 1\r\n  }\r\n\r\n, extend: {\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n     * @param ease function || string Function which should be used for easing or easing keyword\r\n     * @param delay Number indicating the delay before the animation starts\r\n     * @return target || this\r\n     */\r\n    animate: function(o, ease, delay){\r\n\r\n      if(typeof o == 'object'){\r\n        ease = o.ease\r\n        delay = o.delay\r\n        o = o.duration\r\n      }\r\n\r\n      var situation = new SVG.Situation({\r\n        duration: o || 1000,\r\n        delay: delay || 0,\r\n        ease: SVG.easing[ease || '-'] || ease\r\n      })\r\n\r\n      this.queue(situation)\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * sets a delay before the next element of the queue is called\r\n     * @param delay Duration of delay in milliseconds\r\n     * @return this.target()\r\n     */\r\n  , delay: function(delay){\r\n      // The delay is performed by an empty situation with its duration\r\n      // attribute set to the duration of the delay\r\n      var situation = new SVG.Situation({\r\n        duration: delay,\r\n        delay: 0,\r\n        ease: SVG.easing['-']\r\n      })\r\n\r\n      return this.queue(situation)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param null || target SVG.Element which should be set as new target\r\n     * @return target || this\r\n     */\r\n  , target: function(target){\r\n      if(target && target instanceof SVG.Element){\r\n        this._target = target\r\n        return this\r\n      }\r\n\r\n      return this._target\r\n    }\r\n\r\n    // returns the absolute position at a given time\r\n  , timeToAbsPos: function(timestamp){\r\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n    }\r\n\r\n    // returns the timestamp from a given absolute positon\r\n  , absPosToTime: function(absPos){\r\n      return this.situation.duration/this._speed * absPos + this.situation.start\r\n    }\r\n\r\n    // starts the animationloop\r\n  , startAnimFrame: function(){\r\n      this.stopAnimFrame()\r\n      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n    }\r\n\r\n    // cancels the animationframe\r\n  , stopAnimFrame: function(){\r\n      window.cancelAnimationFrame(this.animationFrame)\r\n    }\r\n\r\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n  , start: function(){\r\n      // dont start if already started\r\n      if(!this.active && this.situation){\r\n        this.active = true\r\n        this.startCurrent()\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // start the current situation\r\n  , startCurrent: function(){\r\n      this.situation.start = +new Date + this.situation.delay/this._speed\r\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n      return this.initAnimations().step()\r\n    }\r\n\r\n    /**\r\n     * adds a function / Situation to the animation queue\r\n     * @param fn function / situation to add\r\n     * @return this\r\n     */\r\n  , queue: function(fn){\r\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n        this.situations.push(fn)\r\n\r\n      if(!this.situation) this.situation = this.situations.shift()\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * pulls next element from the queue and execute it\r\n     * @return this\r\n     */\r\n  , dequeue: function(){\r\n      // stop current animation\r\n      this.stop()\r\n\r\n      // get next animation from queue\r\n      this.situation = this.situations.shift()\r\n\r\n      if(this.situation){\r\n        if(this.situation instanceof SVG.Situation) {\r\n          this.start()\r\n        } else {\r\n          // If it is not a SVG.Situation, then it is a function, we execute it\r\n          this.situation.call(this)\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // updates all animations to the current state of the element\r\n    // this is important when one property could be changed from another property\r\n  , initAnimations: function() {\r\n      var i, j, source\r\n      var s = this.situation\r\n\r\n      if(s.init) return this\r\n\r\n      for(i in s.animations){\r\n        source = this.target()[i]()\r\n\r\n        if(!Array.isArray(source)) {\r\n          source = [source]\r\n        }\r\n\r\n        if(!Array.isArray(s.animations[i])) {\r\n          s.animations[i] = [s.animations[i]]\r\n        }\r\n\r\n        //if(s.animations[i].length > source.length) {\r\n        //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))\r\n        //}\r\n\r\n        for(j = source.length; j--;) {\r\n          // The condition is because some methods return a normal number instead\r\n          // of a SVG.Number\r\n          if(s.animations[i][j] instanceof SVG.Number)\r\n            source[j] = new SVG.Number(source[j])\r\n\r\n          s.animations[i][j] = source[j].morph(s.animations[i][j])\r\n        }\r\n      }\r\n\r\n      for(i in s.attrs){\r\n        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n      }\r\n\r\n      for(i in s.styles){\r\n        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n      }\r\n\r\n      s.initialTransformation = this.target().matrixify()\r\n\r\n      s.init = true\r\n      return this\r\n    }\r\n  , clearQueue: function(){\r\n      this.situations = []\r\n      return this\r\n    }\r\n  , clearCurrent: function(){\r\n      this.situation = null\r\n      return this\r\n    }\r\n    /** stops the animation immediately\r\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n     * @return this\r\n     */\r\n  , stop: function(jumpToEnd, clearQueue){\r\n      var active = this.active\r\n      this.active = false\r\n\r\n      if(clearQueue){\r\n        this.clearQueue()\r\n      }\r\n\r\n      if(jumpToEnd && this.situation){\r\n        // initialize the situation if it was not\r\n        !active && this.startCurrent()\r\n        this.atEnd()\r\n      }\r\n\r\n      this.stopAnimFrame()\r\n\r\n      return this.clearCurrent()\r\n    }\r\n\r\n    /** resets the element to the state where the current element has started\r\n     * @return this\r\n     */\r\n  , reset: function(){\r\n      if(this.situation){\r\n        var temp = this.situation\r\n        this.stop()\r\n        this.situation = temp\r\n        this.atStart()\r\n      }\r\n      return this\r\n    }\r\n\r\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n  , finish: function(){\r\n\r\n      this.stop(true, false)\r\n\r\n      while(this.dequeue().situation && this.stop(true, false));\r\n\r\n      this.clearQueue().clearCurrent()\r\n\r\n      return this\r\n    }\r\n\r\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n  , atStart: function() {\r\n      return this.at(0, true)\r\n    }\r\n\r\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n  , atEnd: function() {\r\n      if (this.situation.loops === true) {\r\n        // If in a infinite loop, we end the current iteration\r\n        this.situation.loops = this.situation.loop + 1\r\n      }\r\n\r\n      if(typeof this.situation.loops == 'number') {\r\n        // If performing a finite number of loops, we go after all the loops\r\n        return this.at(this.situation.loops, true)\r\n      } else {\r\n        // If no loops, we just go at the end\r\n        return this.at(1, true)\r\n      }\r\n    }\r\n\r\n    // set the internal animation pointer to the specified position and updates the visualisation\r\n    // if isAbsPos is true, pos is treated as an absolute position\r\n  , at: function(pos, isAbsPos){\r\n      var durDivSpd = this.situation.duration/this._speed\r\n\r\n      this.absPos = pos\r\n      // If pos is not an absolute position, we convert it into one\r\n      if (!isAbsPos) {\r\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n        this.absPos += this.situation.loop\r\n      }\r\n\r\n      this.situation.start = +new Date - this.absPos * durDivSpd\r\n      this.situation.finish = this.situation.start + durDivSpd\r\n\r\n      return this.step(true)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the speed of the animations\r\n     * @param speed null || Number The new speed of the animations\r\n     * @return Number || this\r\n     */\r\n  , speed: function(speed){\r\n      if (speed === 0) return this.pause()\r\n\r\n      if (speed) {\r\n        this._speed = speed\r\n        // We use an absolute position here so that speed can affect the delay before the animation\r\n        return this.at(this.absPos, true)\r\n      } else return this._speed\r\n    }\r\n\r\n    // Make loopable\r\n  , loop: function(times, reverse) {\r\n      var c = this.last()\r\n\r\n      // store total loops\r\n      c.loops = (times != null) ? times : true\r\n      c.loop = 0\r\n\r\n      if(reverse) c.reversing = true\r\n      return this\r\n    }\r\n\r\n    // pauses the animation\r\n  , pause: function(){\r\n      this.paused = true\r\n      this.stopAnimFrame()\r\n\r\n      return this\r\n    }\r\n\r\n    // unpause the animation\r\n  , play: function(){\r\n      if(!this.paused) return this\r\n      this.paused = false\r\n      // We use an absolute position here so that the delay before the animation can be paused\r\n      return this.at(this.absPos, true)\r\n    }\r\n\r\n    /**\r\n     * toggle or set the direction of the animation\r\n     * true sets direction to backwards while false sets it to forwards\r\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n     * @return this\r\n     */\r\n  , reverse: function(reversed){\r\n      var c = this.last()\r\n\r\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n      else c.reversed = reversed\r\n\r\n      return this\r\n    }\r\n\r\n\r\n    /**\r\n     * returns a float from 0-1 indicating the progress of the current animation\r\n     * @param eased Boolean indicating whether the returned position should be eased or not\r\n     * @return number\r\n     */\r\n  , progress: function(easeIt){\r\n      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n    }\r\n\r\n    /**\r\n     * adds a callback function which is called when the current animation is finished\r\n     * @param fn Function which should be executed as callback\r\n     * @return number\r\n     */\r\n  , after: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function wrapper(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, c)\r\n              this.off('finished.fx', wrapper) // prevent memory leak\r\n            }\r\n          }\r\n\r\n      this.target().on('finished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // adds a callback which is called whenever one animation step is performed\r\n  , during: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n            }\r\n          }\r\n\r\n      // see above\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.after(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls after ALL animations in the queue are finished\r\n  , afterAll: function(fn){\r\n      var wrapper = function wrapper(e){\r\n            fn.call(this)\r\n            this.off('allfinished.fx', wrapper)\r\n          }\r\n\r\n      // see above\r\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls on every animation step for all animations\r\n  , duringAll: function(fn){\r\n      var wrapper = function(e){\r\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n          }\r\n\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.afterAll(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n  , last: function(){\r\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n    }\r\n\r\n    // adds one property to the animations\r\n  , add: function(method, args, type){\r\n      this.last()[type || 'animations'][method] = args\r\n      return this._callStart()\r\n    }\r\n\r\n    /** perform one step of the animation\r\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n     *  @return this\r\n     */\r\n  , step: function(ignoreTime){\r\n\r\n      // convert current time to an absolute position\r\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\r\n      // This part convert an absolute position to a position\r\n      if(this.situation.loops !== false) {\r\n        var absPos, absPosInt, lastLoop\r\n\r\n        // If the absolute position is below 0, we just treat it as if it was 0\r\n        absPos = Math.max(this.absPos, 0)\r\n        absPosInt = Math.floor(absPos)\r\n\r\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n          this.pos = absPos - absPosInt\r\n          lastLoop = this.situation.loop\r\n          this.situation.loop = absPosInt\r\n        } else {\r\n          this.absPos = this.situation.loops\r\n          this.pos = 1\r\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n          lastLoop = this.situation.loop - 1\r\n          this.situation.loop = this.situation.loops\r\n        }\r\n\r\n        if(this.situation.reversing) {\r\n          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n        }\r\n\r\n      } else {\r\n        // If there are no loop, the absolute position must not be above 1\r\n        this.absPos = Math.min(this.absPos, 1)\r\n        this.pos = this.absPos\r\n      }\r\n\r\n      // while the absolute position can be below 0, the position must not be below 0\r\n      if(this.pos < 0) this.pos = 0\r\n\r\n      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\r\n\r\n      // apply easing\r\n      var eased = this.situation.ease(this.pos)\r\n\r\n      // call once-callbacks\r\n      for(var i in this.situation.once){\r\n        if(i > this.lastPos && i <= eased){\r\n          this.situation.once[i].call(this.target(), this.pos, eased)\r\n          delete this.situation.once[i]\r\n        }\r\n      }\r\n\r\n      // fire during callback with position, eased position and current situation as parameter\r\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\r\n      // the user may call stop or finish in the during callback\r\n      // so make sure that we still have a valid situation\r\n      if(!this.situation){\r\n        return this\r\n      }\r\n\r\n      // apply the actual animation to every property\r\n      this.eachAt()\r\n\r\n      // do final code when situation is finished\r\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\r\n        // stop animation callback\r\n        this.stopAnimFrame()\r\n\r\n        // fire finished callback with current situation as parameter\r\n        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\r\n        if(!this.situations.length){\r\n          this.target().fire('allfinished')\r\n\r\n          // Recheck the length since the user may call animate in the afterAll callback\r\n          if(!this.situations.length){\r\n            this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n            this.active = false\r\n          }\r\n        }\r\n\r\n        // start next animation\r\n        if(this.active) this.dequeue()\r\n        else this.clearCurrent()\r\n\r\n      }else if(!this.paused && this.active){\r\n        // we continue animating when we are not at the end\r\n        this.startAnimFrame()\r\n      }\r\n\r\n      // save last eased position for once callback triggering\r\n      this.lastPos = eased\r\n      return this\r\n\r\n    }\r\n\r\n    // calculates the step for every property and calls block with it\r\n  , eachAt: function(){\r\n      var i, len, at, self = this, target = this.target(), s = this.situation\r\n\r\n      // apply animations which can be called trough a method\r\n      for(i in s.animations){\r\n\r\n        at = [].concat(s.animations[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target[i].apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with attr()\r\n      for(i in s.attrs){\r\n\r\n        at = [i].concat(s.attrs[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.attr.apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with style()\r\n      for(i in s.styles){\r\n\r\n        at = [i].concat(s.styles[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.style.apply(target, at)\r\n\r\n      }\r\n\r\n      // animate initialTransformation which has to be chained\r\n      if(s.transforms.length){\r\n\r\n        // get initial initialTransformation\r\n        at = s.initialTransformation\r\n        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\r\n          // get next transformation in chain\r\n          var a = s.transforms[i]\r\n\r\n          // multiply matrix directly\r\n          if(a instanceof SVG.Matrix){\r\n\r\n            if(a.relative){\r\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n            }else{\r\n              at = at.morph(a).at(s.ease(this.pos))\r\n            }\r\n            continue\r\n          }\r\n\r\n          // when transformation is absolute we have to reset the needed transformation first\r\n          if(!a.relative)\r\n            a.undo(at.extract())\r\n\r\n          // and reapply it after\r\n          at = at.multiply(a.at(s.ease(this.pos)))\r\n\r\n        }\r\n\r\n        // set new matrix on element\r\n        target.matrix(at)\r\n      }\r\n\r\n      return this\r\n\r\n    }\r\n\r\n\r\n    // adds an once-callback which is called at a specific position and never again\r\n  , once: function(pos, fn, isEased){\r\n      var c = this.last()\r\n      if(!isEased) pos = c.ease(pos)\r\n\r\n      c.once[pos] = fn\r\n\r\n      return this\r\n    }\r\n\r\n  , _callStart: function() {\r\n      setTimeout(function(){this.start()}.bind(this), 0)\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n, parent: SVG.Element\r\n\r\n  // Add method to parent elements\r\n, construct: {\r\n    // Get fx module or create a new one, then animate with given duration and ease\r\n    animate: function(o, ease, delay) {\r\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n    }\r\n  , delay: function(delay){\r\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n    }\r\n  , stop: function(jumpToEnd, clearQueue) {\r\n      if (this.fx)\r\n        this.fx.stop(jumpToEnd, clearQueue)\r\n\r\n      return this\r\n    }\r\n  , finish: function() {\r\n      if (this.fx)\r\n        this.fx.finish()\r\n\r\n      return this\r\n    }\r\n    // Pause current animation\r\n  , pause: function() {\r\n      if (this.fx)\r\n        this.fx.pause()\r\n\r\n      return this\r\n    }\r\n    // Play paused current animation\r\n  , play: function() {\r\n      if (this.fx)\r\n        this.fx.play()\r\n\r\n      return this\r\n    }\r\n    // Set/Get the speed of the animations\r\n  , speed: function(speed) {\r\n      if (this.fx)\r\n        if (speed == null)\r\n          return this.fx.speed()\r\n        else\r\n          this.fx.speed(speed)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\n// MorphObj is used whenever no morphable object is given\r\nSVG.MorphObj = SVG.invent({\r\n\r\n  create: function(from, to){\r\n    // prepare color for morphing\r\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n    // prepare value list for morphing\r\n    if(SVG.regex.delimiter.test(from)) return new SVG.Array(from).morph(to)\r\n    // prepare number for morphing\r\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\r\n    // prepare for plain morphing\r\n    this.value = from\r\n    this.destination = to\r\n  }\r\n\r\n, extend: {\r\n    at: function(pos, real){\r\n      return real < 1 ? this.value : this.destination\r\n    },\r\n\r\n    valueOf: function(){\r\n      return this.value\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  // Add animatable attributes\r\n  attr: function(a, v, relative) {\r\n    // apply attributes individually\r\n    if (typeof a == 'object') {\r\n      for (var key in a)\r\n        this.attr(key, a[key])\r\n\r\n    } else {\r\n      this.add(a, v, 'attrs')\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable styles\r\n, style: function(s, v) {\r\n    if (typeof s == 'object')\r\n      for (var key in s)\r\n        this.style(key, s[key])\r\n\r\n    else\r\n      this.add(s, v, 'styles')\r\n\r\n    return this\r\n  }\r\n  // Animatable x-axis\r\n, x: function(x, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({x:x}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(x)\r\n    num.relative = relative\r\n    return this.add('x', num)\r\n  }\r\n  // Animatable y-axis\r\n, y: function(y, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({y:y}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(y)\r\n    num.relative = relative\r\n    return this.add('y', num)\r\n  }\r\n  // Animatable center x-axis\r\n, cx: function(x) {\r\n    return this.add('cx', new SVG.Number(x))\r\n  }\r\n  // Animatable center y-axis\r\n, cy: function(y) {\r\n    return this.add('cy', new SVG.Number(y))\r\n  }\r\n  // Add animatable move\r\n, move: function(x, y) {\r\n    return this.x(x).y(y)\r\n  }\r\n  // Add animatable center\r\n, center: function(x, y) {\r\n    return this.cx(x).cy(y)\r\n  }\r\n  // Add animatable size\r\n, size: function(width, height) {\r\n    if (this.target() instanceof SVG.Text) {\r\n      // animate font size for Text elements\r\n      this.attr('font-size', width)\r\n\r\n    } else {\r\n      // animate bbox based size for all other elements\r\n      var box\r\n\r\n      if(!width || !height){\r\n        box = this.target().bbox()\r\n      }\r\n\r\n      if(!width){\r\n        width = box.width / box.height  * height\r\n      }\r\n\r\n      if(!height){\r\n        height = box.height / box.width  * width\r\n      }\r\n\r\n      this.add('width' , new SVG.Number(width))\r\n          .add('height', new SVG.Number(height))\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable width\r\n, width: function(width) {\r\n    return this.add('width', new SVG.Number(width))\r\n  }\r\n  // Add animatable height\r\n, height: function(height) {\r\n    return this.add('height', new SVG.Number(height))\r\n  }\r\n  // Add animatable plot\r\n, plot: function(a, b, c, d) {\r\n    // Lines can be plotted with 4 arguments\r\n    if(arguments.length == 4) {\r\n      return this.plot([a, b, c, d])\r\n    }\r\n\r\n    return this.add('plot', new (this.target().morphArray)(a))\r\n  }\r\n  // Add leading method\r\n, leading: function(value) {\r\n    return this.target().leading ?\r\n      this.add('leading', new SVG.Number(value)) :\r\n      this\r\n  }\r\n  // Add animatable viewbox\r\n, viewbox: function(x, y, width, height) {\r\n    if (this.target() instanceof SVG.Container) {\r\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n    return this\r\n  }\r\n, update: function(o) {\r\n    if (this.target() instanceof SVG.Stop) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        return this.update({\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        })\r\n      }\r\n\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', o.offset)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\r\n\nSVG.Box = SVG.invent({\r\n  create: function(x, y, width, height) {\r\n    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n      // chromes getBoundingClientRect has no x and y property\r\n      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n    } else if (arguments.length == 4) {\r\n      this.x = x\r\n      this.y = y\r\n      this.width = width\r\n      this.height = height\r\n    }\r\n\r\n    // add center, right, bottom...\r\n    fullBox(this)\r\n  }\r\n, extend: {\r\n    // Merge rect box with another, return a new instance\r\n    merge: function(box) {\r\n      var b = new this.constructor()\r\n\r\n      // merge boxes\r\n      b.x      = Math.min(this.x, box.x)\r\n      b.y      = Math.min(this.y, box.y)\r\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\r\n      return fullBox(b)\r\n    }\r\n\r\n  , transform: function(m) {\r\n      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p, bbox\r\n\r\n      var pts = [\r\n        new SVG.Point(this.x, this.y),\r\n        new SVG.Point(this.x2, this.y),\r\n        new SVG.Point(this.x, this.y2),\r\n        new SVG.Point(this.x2, this.y2)\r\n      ]\r\n\r\n      pts.forEach(function(p) {\r\n        p = p.transform(m)\r\n        xMin = Math.min(xMin,p.x)\r\n        xMax = Math.max(xMax,p.x)\r\n        yMin = Math.min(yMin,p.y)\r\n        yMax = Math.max(yMax,p.y)\r\n      })\r\n\r\n      bbox = new this.constructor()\r\n      bbox.x = xMin\r\n      bbox.width = xMax-xMin\r\n      bbox.y = yMin\r\n      bbox.height = yMax-yMin\r\n\r\n      fullBox(bbox)\r\n\r\n      return bbox\r\n    }\r\n  }\r\n})\r\n\r\nSVG.BBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    // get values if element is given\r\n    if (element instanceof SVG.Element) {\r\n      var box\r\n\r\n      // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered\r\n      try {\r\n\r\n        if (!document.documentElement.contains){\r\n          // This is IE - it does not support contains() for top-level SVGs\r\n          var topParent = element.node\r\n          while (topParent.parentNode){\r\n            topParent = topParent.parentNode\r\n          }\r\n          if (topParent != document) throw new Exception('Element not in the dom')\r\n        } else {\r\n          // the element is NOT in the dom, throw error\r\n          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n        }\r\n\r\n        // find native bbox\r\n        box = element.node.getBBox()\r\n      } catch(e) {\r\n        if(element instanceof SVG.Shape){\r\n          var clone = element.clone(SVG.parser.draw.instance).show()\r\n          box = clone.node.getBBox()\r\n          clone.remove()\r\n        }else{\r\n          box = {\r\n            x:      element.node.clientLeft\r\n          , y:      element.node.clientTop\r\n          , width:  element.node.clientWidth\r\n          , height: element.node.clientHeight\r\n          }\r\n        }\r\n      }\r\n\r\n      SVG.Box.call(this, box)\r\n    }\r\n\r\n  }\r\n\r\n  // Define ancestor\r\n, inherit: SVG.Box\r\n\r\n  // Define Parent\r\n, parent: SVG.Element\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get bounding box\r\n    bbox: function() {\r\n      return new SVG.BBox(this)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.BBox.prototype.constructor = SVG.BBox\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  tbox: function(){\r\n    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n    return this.rbox(this.doc())\r\n  }\r\n})\r\n\r\nSVG.RBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    if (element instanceof SVG.Element) {\r\n      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n    }\r\n  }\r\n\r\n, inherit: SVG.Box\r\n\r\n  // define Parent\r\n, parent: SVG.Element\r\n\r\n, extend: {\r\n    addOffset: function() {\r\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n      this.x += window.pageXOffset\r\n      this.y += window.pageYOffset\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get rect box\r\n    rbox: function(el) {\r\n      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n      return new SVG.RBox(this).addOffset()\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.RBox.prototype.constructor = SVG.RBox\r\n\nSVG.Matrix = SVG.invent({\r\n  // Initialize\r\n  create: function(source) {\r\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\r\n    // ensure source as object\r\n    source = source instanceof SVG.Element ?\r\n      source.matrixify() :\r\n    typeof source === 'string' ?\r\n      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n    arguments.length == 6 ?\r\n      arrayToMatrix([].slice.call(arguments)) :\r\n    Array.isArray(source) ?\r\n      arrayToMatrix(source) :\r\n    typeof source === 'object' ?\r\n      source : base\r\n\r\n    // merge source\r\n    for (i = abcdef.length - 1; i >= 0; --i)\r\n      this[abcdef[i]] = source[abcdef[i]] != null ?\r\n        source[abcdef[i]] : base[abcdef[i]]\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Extract individual transformations\r\n    extract: function() {\r\n      // find delta transform points\r\n      var px    = deltaTransformPoint(this, 0, 1)\r\n        , py    = deltaTransformPoint(this, 1, 0)\r\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\r\n      return {\r\n        // translation\r\n        x:        this.e\r\n      , y:        this.f\r\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // skew\r\n      , skewX:    -skewX\r\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n        // scale\r\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // rotation\r\n      , rotation: skewX\r\n      , a: this.a\r\n      , b: this.b\r\n      , c: this.c\r\n      , d: this.d\r\n      , e: this.e\r\n      , f: this.f\r\n      , matrix: new SVG.Matrix(this)\r\n      }\r\n    }\r\n    // Clone matrix\r\n  , clone: function() {\r\n      return new SVG.Matrix(this)\r\n    }\r\n    // Morph one matrix into another\r\n  , morph: function(matrix) {\r\n      // store new destination\r\n      this.destination = new SVG.Matrix(matrix)\r\n\r\n      return this\r\n    }\r\n    // Get morphed matrix at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var matrix = new SVG.Matrix({\r\n        a: this.a + (this.destination.a - this.a) * pos\r\n      , b: this.b + (this.destination.b - this.b) * pos\r\n      , c: this.c + (this.destination.c - this.c) * pos\r\n      , d: this.d + (this.destination.d - this.d) * pos\r\n      , e: this.e + (this.destination.e - this.e) * pos\r\n      , f: this.f + (this.destination.f - this.f) * pos\r\n      })\r\n\r\n      return matrix\r\n    }\r\n    // Multiplies by given matrix\r\n  , multiply: function(matrix) {\r\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n    }\r\n    // Inverses matrix\r\n  , inverse: function() {\r\n      return new SVG.Matrix(this.native().inverse())\r\n    }\r\n    // Translate matrix\r\n  , translate: function(x, y) {\r\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n    }\r\n    // Scale matrix\r\n  , scale: function(x, y, cx, cy) {\r\n      // support uniformal scale\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n    }\r\n    // Rotate matrix\r\n  , rotate: function(r, cx, cy) {\r\n      // convert degrees to radians\r\n      r = SVG.utils.radians(r)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n    }\r\n    // Flip matrix on x or y, at a given offset\r\n  , flip: function(a, o) {\r\n      return a == 'x' ?\r\n          this.scale(-1, 1, o, 0) :\r\n        a == 'y' ?\r\n          this.scale(1, -1, 0, o) :\r\n          this.scale(-1, -1, a, o != null ? o : a)\r\n    }\r\n    // Skew\r\n  , skew: function(x, y, cx, cy) {\r\n      // support uniformal skew\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      // convert degrees to radians\r\n      x = SVG.utils.radians(x)\r\n      y = SVG.utils.radians(y)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n    }\r\n    // SkewX\r\n  , skewX: function(x, cx, cy) {\r\n      return this.skew(x, 0, cx, cy)\r\n    }\r\n    // SkewY\r\n  , skewY: function(y, cx, cy) {\r\n      return this.skew(0, y, cx, cy)\r\n    }\r\n    // Transform around a center point\r\n  , around: function(cx, cy, matrix) {\r\n      return this\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n        .multiply(matrix)\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n    }\r\n    // Convert to native SVGMatrix\r\n  , native: function() {\r\n      // create new matrix\r\n      var matrix = SVG.parser.native.createSVGMatrix()\r\n\r\n      // update with current values\r\n      for (var i = abcdef.length - 1; i >= 0; i--)\r\n        matrix[abcdef[i]] = this[abcdef[i]]\r\n\r\n      return matrix\r\n    }\r\n    // Convert matrix to string\r\n  , toString: function() {\r\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n    }\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Element\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Get current matrix\r\n    ctm: function() {\r\n      return new SVG.Matrix(this.node.getCTM())\r\n    },\r\n    // Get current screen matrix\r\n    screenCTM: function() {\r\n      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n         This is needed because FF does not return the transformation matrix\r\n         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n         However all other Browsers do that */\r\n      if(this instanceof SVG.Nested) {\r\n        var rect = this.rect(1,1)\r\n        var m = rect.node.getScreenCTM()\r\n        rect.remove()\r\n        return new SVG.Matrix(m)\r\n      }\r\n      return new SVG.Matrix(this.node.getScreenCTM())\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\nSVG.Point = SVG.invent({\r\n  // Initialize\r\n  create: function(x,y) {\r\n    var i, source, base = {x:0, y:0}\r\n\r\n    // ensure source as object\r\n    source = Array.isArray(x) ?\r\n      {x:x[0], y:x[1]} :\r\n    typeof x === 'object' ?\r\n      {x:x.x, y:x.y} :\r\n    x != null ?\r\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\r\n    // merge source\r\n    this.x = source.x\r\n    this.y = source.y\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Clone point\r\n    clone: function() {\r\n      return new SVG.Point(this)\r\n    }\r\n    // Morph one point into another\r\n  , morph: function(x, y) {\r\n      // store new destination\r\n      this.destination = new SVG.Point(x, y)\r\n\r\n      return this\r\n    }\r\n    // Get morphed point at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var point = new SVG.Point({\r\n        x: this.x + (this.destination.x - this.x) * pos\r\n      , y: this.y + (this.destination.y - this.y) * pos\r\n      })\r\n\r\n      return point\r\n    }\r\n    // Convert to native SVGPoint\r\n  , native: function() {\r\n      // create new point\r\n      var point = SVG.parser.native.createSVGPoint()\r\n\r\n      // update with current values\r\n      point.x = this.x\r\n      point.y = this.y\r\n\r\n      return point\r\n    }\r\n    // transform point with matrix\r\n  , transform: function(matrix) {\r\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n\r\n  // Get point\r\n  point: function(x, y) {\r\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Set svg element attribute\r\n  attr: function(a, v, n) {\r\n    // act as full getter\r\n    if (a == null) {\r\n      // get an object of attributes\r\n      a = {}\r\n      v = this.node.attributes\r\n      for (n = v.length - 1; n >= 0; n--)\r\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n\r\n      return a\r\n\r\n    } else if (typeof a == 'object') {\r\n      // apply every attribute individually if an object is passed\r\n      for (v in a) this.attr(v, a[v])\r\n\r\n    } else if (v === null) {\r\n        // remove value\r\n        this.node.removeAttribute(a)\r\n\r\n    } else if (v == null) {\r\n      // act as a getter if the first and only argument is not an object\r\n      v = this.node.getAttribute(a)\r\n      return v == null ?\r\n        SVG.defaults.attrs[a] :\r\n      SVG.regex.isNumber.test(v) ?\r\n        parseFloat(v) : v\r\n\r\n    } else {\r\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n      if (a == 'stroke-width')\r\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n      else if (a == 'stroke')\r\n        this._stroke = v\r\n\r\n      // convert image fill and stroke to patterns\r\n      if (a == 'fill' || a == 'stroke') {\r\n        if (SVG.regex.isImage.test(v))\r\n          v = this.doc().defs().image(v, 0, 0)\r\n\r\n        if (v instanceof SVG.Image)\r\n          v = this.doc().defs().pattern(0, 0, function() {\r\n            this.add(v)\r\n          })\r\n      }\r\n\r\n      // ensure correct numeric values (also accepts NaN and Infinity)\r\n      if (typeof v === 'number')\r\n        v = new SVG.Number(v)\r\n\r\n      // ensure full hex color\r\n      else if (SVG.Color.isColor(v))\r\n        v = new SVG.Color(v)\r\n\r\n      // parse array values\r\n      else if (Array.isArray(v))\r\n        v = new SVG.Array(v)\r\n\r\n      // if the passed attribute is leading...\r\n      if (a == 'leading') {\r\n        // ... call the leading method instead\r\n        if (this.leading)\r\n          this.leading(v)\r\n      } else {\r\n        // set given attribute on node\r\n        typeof n === 'string' ?\r\n          this.node.setAttributeNS(n, a, v.toString()) :\r\n          this.node.setAttribute(a, v.toString())\r\n      }\r\n\r\n      // rebuild if required\r\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n        this.rebuild(a, v)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Add transformations\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // get current matrix\r\n    matrix = new SVG.Matrix(target)\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.multiply(new SVG.Matrix(o)) :\r\n        // absolute\r\n        new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n        // absolute\r\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      if (!relative) {\r\n        // absolute; multiply inversed values\r\n        var e = matrix.extract()\r\n        o.scaleX = o.scaleX * 1 / e.scaleX\r\n        o.scaleY = o.scaleY * 1 / e.scaleY\r\n      }\r\n\r\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\r\n      if (!relative) {\r\n        // absolute; reset skew values\r\n        var e = matrix.extract()\r\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n      }\r\n\r\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      if (relative) {\r\n        // relative\r\n        matrix = matrix.translate(o.x, o.y)\r\n      } else {\r\n        // absolute\r\n        if (o.x != null) matrix.e = o.x\r\n        if (o.y != null) matrix.f = o.y\r\n      }\r\n    }\r\n\r\n    return this.attr('transform', matrix)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this.target()\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skewY != null ? o.skewY : 0\r\n\r\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      matrix = new SVG.Translate(o.x, o.y)\r\n    }\r\n\r\n    if(!matrix) return this\r\n\r\n    matrix.relative = relative\r\n\r\n    this.last().transforms.push(matrix)\r\n\r\n    return this._callStart()\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Reset all transformations\r\n  untransform: function() {\r\n    return this.attr('transform', null)\r\n  },\r\n  // merge the whole transformation chain into one matrix and returns it\r\n  matrixify: function() {\r\n\r\n    var matrix = (this.attr('transform') || '')\r\n      // split transformations\r\n      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n        // generate key => value pairs\r\n        var kv = str.trim().split('(')\r\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n      })\r\n      // merge every transformation into one matrix\r\n      .reduce(function(matrix, transform){\r\n\r\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n        return matrix[transform[0]].apply(matrix, transform[1])\r\n\r\n      }, new SVG.Matrix())\r\n\r\n    return matrix\r\n  },\r\n  // add an element to another parent without changing the visual representation on the screen\r\n  toParent: function(parent) {\r\n    if(this == parent) return this\r\n    var ctm = this.screenCTM()\r\n    var pCtm = parent.screenCTM().inverse()\r\n\r\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\r\n    return this\r\n  },\r\n  // same as above with parent equals root-svg\r\n  toDoc: function() {\r\n    return this.toParent(this.doc())\r\n  }\r\n\r\n})\r\n\r\nSVG.Transformation = SVG.invent({\r\n\r\n  create: function(source, inversed){\r\n\r\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n      return this.constructor.call(this, [].slice.call(arguments))\r\n    }\r\n\r\n    if(Array.isArray(source)){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[i]\r\n      }\r\n    } else if(typeof source == 'object'){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[this.arguments[i]]\r\n      }\r\n    }\r\n\r\n    this.inversed = false\r\n\r\n    if(inversed === true){\r\n      this.inversed = true\r\n    }\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    arguments: []\r\n  , method: ''\r\n\r\n  , at: function(pos){\r\n\r\n      var params = []\r\n\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        params.push(this[this.arguments[i]])\r\n      }\r\n\r\n      var m = this._undo || new SVG.Matrix()\r\n\r\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\r\n      return this.inversed ? m.inverse() : m\r\n\r\n    }\r\n\r\n  , undo: function(o){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n      }\r\n\r\n      // The method SVG.Matrix.extract which was used before calling this\r\n      // method to obtain a value for the parameter o doesn't return a cx and\r\n      // a cy so we use the ones that were provided to this object at its creation\r\n      o.cx = this.cx\r\n      o.cy = this.cy\r\n\r\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.Translate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['transformedX', 'transformedY']\r\n  , method: 'translate'\r\n  }\r\n\r\n})\r\n\r\nSVG.Rotate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['rotation', 'cx', 'cy']\r\n  , method: 'rotate'\r\n  , at: function(pos){\r\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n      return this.inversed ? m.inverse() : m\r\n    }\r\n  , undo: function(o){\r\n      this._undo = o\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Scale = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n  , method: 'scale'\r\n  }\r\n\r\n})\r\n\r\nSVG.Skew = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n  , method: 'skew'\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Dynamic style generator\r\n  style: function(s, v) {\r\n    if (arguments.length == 0) {\r\n      // get full style\r\n      return this.node.style.cssText || ''\r\n\r\n    } else if (arguments.length < 2) {\r\n      // apply every style individually if an object is passed\r\n      if (typeof s == 'object') {\r\n        for (v in s) this.style(v, s[v])\r\n\r\n      } else if (SVG.regex.isCss.test(s)) {\r\n        // parse css string\r\n        s = s.split(/\\s*;\\s*/)\r\n          // filter out suffix ; and stuff like ;;\r\n          .filter(function(e) { return !!e })\r\n          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\r\n        // apply every definition individually\r\n        while (v = s.pop()) {\r\n          this.style(v[0], v[1])\r\n        }\r\n      } else {\r\n        // act as a getter if the first and only argument is not an object\r\n        return this.node.style[camelCase(s)]\r\n      }\r\n\r\n    } else {\r\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.Parent = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Returns all child elements\r\n    children: function() {\r\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n        return SVG.adopt(node)\r\n      })\r\n    }\r\n    // Add given element at a position\r\n  , add: function(element, i) {\r\n      if (i == null)\r\n        this.node.appendChild(element.node)\r\n      else if (element.node != this.node.childNodes[i])\r\n        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\r\n      return this\r\n    }\r\n    // Basically does the same as `add()` but returns the added element instead\r\n  , put: function(element, i) {\r\n      this.add(element, i)\r\n      return element\r\n    }\r\n    // Checks if the given element is a child\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // Gets index of given element\r\n  , index: function(element) {\r\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n    }\r\n    // Get a element at the given index\r\n  , get: function(i) {\r\n      return SVG.adopt(this.node.childNodes[i])\r\n    }\r\n    // Get first child\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get the last child\r\n  , last: function() {\r\n      return this.get(this.node.childNodes.length - 1)\r\n    }\r\n    // Iterates over all children and invokes a given block\r\n  , each: function(block, deep) {\r\n      var i, il\r\n        , children = this.children()\r\n\r\n      for (i = 0, il = children.length; i < il; i++) {\r\n        if (children[i] instanceof SVG.Element)\r\n          block.apply(children[i], [i, children])\r\n\r\n        if (deep && (children[i] instanceof SVG.Container))\r\n          children[i].each(block, deep)\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove a given child\r\n  , removeElement: function(element) {\r\n      this.node.removeChild(element.node)\r\n\r\n      return this\r\n    }\r\n    // Remove all elements in this container\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      return this\r\n    }\r\n  , // Get defs\r\n    defs: function() {\r\n      return this.doc().defs()\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Parent, {\r\n\r\n  ungroup: function(parent, depth) {\r\n    if(depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this\r\n\r\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n    depth = depth || Infinity\r\n\r\n    this.each(function(){\r\n      if(this instanceof SVG.Defs) return this\r\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n      return this.toParent(parent)\r\n    })\r\n\r\n    this.node.firstChild || this.remove()\r\n\r\n    return this\r\n  },\r\n\r\n  flatten: function(parent, depth) {\r\n    return this.ungroup(parent, depth)\r\n  }\r\n\r\n})\nSVG.Container = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n})\n\r\nSVG.ViewBox = SVG.invent({\r\n\r\n  create: function(source) {\r\n    var i, base = [0, 0, 0, 0]\r\n\r\n    var x, y, width, height, box, view, we, he\r\n      , wm   = 1 // width multiplier\r\n      , hm   = 1 // height multiplier\r\n      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\r\n    if(source instanceof SVG.Element){\r\n\r\n      we = source\r\n      he = source\r\n      view = (source.attr('viewBox') || '').match(reg)\r\n      box = source.bbox\r\n\r\n      // get dimensions of current node\r\n      width  = new SVG.Number(source.width())\r\n      height = new SVG.Number(source.height())\r\n\r\n      // find nearest non-percentual dimensions\r\n      while (width.unit == '%') {\r\n        wm *= width.value\r\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n        we = we.parent()\r\n      }\r\n      while (height.unit == '%') {\r\n        hm *= height.value\r\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n        he = he.parent()\r\n      }\r\n\r\n      // ensure defaults\r\n      this.x      = 0\r\n      this.y      = 0\r\n      this.width  = width  * wm\r\n      this.height = height * hm\r\n      this.zoom   = 1\r\n\r\n      if (view) {\r\n        // get width and height from viewbox\r\n        x      = parseFloat(view[0])\r\n        y      = parseFloat(view[1])\r\n        width  = parseFloat(view[2])\r\n        height = parseFloat(view[3])\r\n\r\n        // calculate zoom accoring to viewbox\r\n        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n          this.height / height :\r\n          this.width  / width\r\n\r\n        // calculate real pixel dimensions on parent SVG.Doc element\r\n        this.x      = x\r\n        this.y      = y\r\n        this.width  = width\r\n        this.height = height\r\n\r\n      }\r\n\r\n    }else{\r\n\r\n      // ensure source as object\r\n      source = typeof source === 'string' ?\r\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n      Array.isArray(source) ?\r\n        source :\r\n      typeof source == 'object' ?\r\n        [source.x, source.y, source.width, source.height] :\r\n      arguments.length == 4 ?\r\n        [].slice.call(arguments) :\r\n        base\r\n\r\n      this.x = source[0]\r\n      this.y = source[1]\r\n      this.width = source[2]\r\n      this.height = source[3]\r\n    }\r\n\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    toString: function() {\r\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n    }\r\n  , morph: function(x, y, width, height){\r\n      this.destination = new SVG.ViewBox(x, y, width, height)\r\n      return this\r\n    }\r\n\r\n  , at: function(pos) {\r\n\r\n      if(!this.destination) return this\r\n\r\n      return new SVG.ViewBox([\r\n          this.x + (this.destination.x - this.x) * pos\r\n        , this.y + (this.destination.y - this.y) * pos\r\n        , this.width + (this.destination.width - this.width) * pos\r\n        , this.height + (this.destination.height - this.height) * pos\r\n      ])\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n\r\n    // get/set viewbox\r\n    viewbox: function(x, y, width, height) {\r\n      if (arguments.length == 0)\r\n        // act as a getter if there are no arguments\r\n        return new SVG.ViewBox(this)\r\n\r\n      // otherwise act as a setter\r\n      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n  }\r\n\r\n})\n// Add events to elements\r\n;[  'click'\r\n  , 'dblclick'\r\n  , 'mousedown'\r\n  , 'mouseup'\r\n  , 'mouseover'\r\n  , 'mouseout'\r\n  , 'mousemove'\r\n  // , 'mouseenter' -> not supported by IE\r\n  // , 'mouseleave' -> not supported by IE\r\n  , 'touchstart'\r\n  , 'touchmove'\r\n  , 'touchleave'\r\n  , 'touchend'\r\n  , 'touchcancel' ].forEach(function(event) {\r\n\r\n  // add event to SVG.Element\r\n  SVG.Element.prototype[event] = function(f) {\r\n    // bind event to element rather than element node\r\n    SVG.on(this.node, event, f)\r\n    return this\r\n  }\r\n})\r\n\r\n// Initialize listeners stack\r\nSVG.listeners = []\r\nSVG.handlerMap = []\r\nSVG.listenerId = 0\r\n\r\n// Add event binder in the SVG namespace\r\nSVG.on = function(node, event, listener, binding, options) {\r\n  // create listener, get object-index\r\n  var l     = listener.bind(binding || node.instance || node)\r\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n    , ev    = event.split('.')[0]\r\n    , ns    = event.split('.')[1] || '*'\r\n\r\n\r\n  // ensure valid object\r\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\r\n  if(!listener._svgjsListenerId)\r\n    listener._svgjsListenerId = ++SVG.listenerId\r\n\r\n  // reference listener\r\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\r\n  // add listener\r\n  node.addEventListener(ev, l, options || false)\r\n}\r\n\r\n// Add event unbinder in the SVG namespace\r\nSVG.off = function(node, event, listener) {\r\n  var index = SVG.handlerMap.indexOf(node)\r\n    , ev    = event && event.split('.')[0]\r\n    , ns    = event && event.split('.')[1]\r\n    , namespace = ''\r\n\r\n  if(index == -1) return\r\n\r\n  if (listener) {\r\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n    if(!listener) return\r\n\r\n    // remove listener reference\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n      // remove listener\r\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\r\n      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n    }\r\n\r\n  } else if (ns && ev) {\r\n    // remove all listeners for a namespaced event\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n      for (listener in SVG.listeners[index][ev][ns])\r\n        SVG.off(node, [ev, ns].join('.'), listener)\r\n\r\n      delete SVG.listeners[index][ev][ns]\r\n    }\r\n\r\n  } else if (ns){\r\n    // remove all listeners for a specific namespace\r\n    for(event in SVG.listeners[index]){\r\n        for(namespace in SVG.listeners[index][event]){\r\n            if(ns === namespace){\r\n                SVG.off(node, [event, ns].join('.'))\r\n            }\r\n        }\r\n    }\r\n\r\n  } else if (ev) {\r\n    // remove all listeners for the event\r\n    if (SVG.listeners[index][ev]) {\r\n      for (namespace in SVG.listeners[index][ev])\r\n        SVG.off(node, [ev, namespace].join('.'))\r\n\r\n      delete SVG.listeners[index][ev]\r\n    }\r\n\r\n  } else {\r\n    // remove all listeners on a given node\r\n    for (event in SVG.listeners[index])\r\n      SVG.off(node, event)\r\n\r\n    delete SVG.listeners[index]\r\n    delete SVG.handlerMap[index]\r\n\r\n  }\r\n}\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Bind given event to listener\r\n  on: function(event, listener, binding, options) {\r\n    SVG.on(this.node, event, listener, binding, options)\r\n\r\n    return this\r\n  }\r\n  // Unbind event from listener\r\n, off: function(event, listener) {\r\n    SVG.off(this.node, event, listener)\r\n\r\n    return this\r\n  }\r\n  // Fire given event\r\n, fire: function(event, data) {\r\n\r\n    // Dispatch event\r\n    if(event instanceof window.Event){\r\n        this.node.dispatchEvent(event)\r\n    }else{\r\n        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n    }\r\n\r\n    this._event = event\r\n    return this\r\n  }\r\n, event: function() {\r\n    return this._event\r\n  }\r\n})\r\n\n\r\nSVG.Defs = SVG.invent({\r\n  // Initialize node\r\n  create: 'defs'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n})\nSVG.G = SVG.invent({\r\n  // Initialize node\r\n  create: 'g'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n    }\r\n  , gbox: function() {\r\n\r\n      var bbox  = this.bbox()\r\n        , trans = this.transform()\r\n\r\n      bbox.x  += trans.x\r\n      bbox.x2 += trans.x\r\n      bbox.cx += trans.x\r\n\r\n      bbox.y  += trans.y\r\n      bbox.y2 += trans.y\r\n      bbox.cy += trans.y\r\n\r\n      return bbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a group element\r\n    group: function() {\r\n      return this.put(new SVG.G)\r\n    }\r\n  }\r\n})\r\n\n// ### This module adds backward / forward functionality to elements.\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Get all siblings, including myself\r\n  siblings: function() {\r\n    return this.parent().children()\r\n  }\r\n  // Get the curent position siblings\r\n, position: function() {\r\n    return this.parent().index(this)\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, next: function() {\r\n    return this.siblings()[this.position() + 1]\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, previous: function() {\r\n    return this.siblings()[this.position() - 1]\r\n  }\r\n  // Send given element one step forward\r\n, forward: function() {\r\n    var i = this.position() + 1\r\n      , p = this.parent()\r\n\r\n    // move node one step forward\r\n    p.removeElement(this).add(this, i)\r\n\r\n    // make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element one step backward\r\n, backward: function() {\r\n    var i = this.position()\r\n\r\n    if (i > 0)\r\n      this.parent().removeElement(this).add(this, i - 1)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the front\r\n, front: function() {\r\n    var p = this.parent()\r\n\r\n    // Move node forward\r\n    p.node.appendChild(this.node)\r\n\r\n    // Make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the back\r\n, back: function() {\r\n    if (this.position() > 0)\r\n      this.parent().removeElement(this).add(this, 0)\r\n\r\n    return this\r\n  }\r\n  // Inserts a given element before the targeted element\r\n, before: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i)\r\n\r\n    return this\r\n  }\r\n  // Insters a given element after the targeted element\r\n, after: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i + 1)\r\n\r\n    return this\r\n  }\r\n\r\n})\nSVG.Mask = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('mask'))\r\n\r\n    // keep references to masked elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unmask all masked elements and remove itself\r\n    remove: function() {\r\n      // unmask all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unmask()\r\n      this.targets = []\r\n\r\n      // remove mask from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create masking element\r\n    mask: function() {\r\n      return this.defs().put(new SVG.Mask)\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Distribute mask to svg element\r\n  maskWith: function(element) {\r\n    // use given mask or create a new one\r\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.masker.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n  }\r\n  // Unmask element\r\n, unmask: function() {\r\n    delete this.masker\r\n    return this.attr('mask', null)\r\n  }\r\n\r\n})\r\n\nSVG.ClipPath = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('clipPath'))\r\n\r\n    // keep references to clipped elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unclip all clipped elements and remove itself\r\n    remove: function() {\r\n      // unclip all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unclip()\r\n      this.targets = []\r\n\r\n      // remove clipPath from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create clipping element\r\n    clip: function() {\r\n      return this.defs().put(new SVG.ClipPath)\r\n    }\r\n  }\r\n})\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Distribute clipPath to svg element\r\n  clipWith: function(element) {\r\n    // use given clip or create a new one\r\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.clipper.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n  }\r\n  // Unclip element\r\n, unclip: function() {\r\n    delete this.clipper\r\n    return this.attr('clip-path', null)\r\n  }\r\n\r\n})\nSVG.Gradient = SVG.invent({\r\n  // Initialize node\r\n  create: function(type) {\r\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n\r\n    // store type\r\n    this.type = type\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add a color stop\r\n    at: function(offset, color, opacity) {\r\n      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n    }\r\n    // Update gradient\r\n  , update: function(block) {\r\n      // remove all stops\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'gradientTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create gradient element in defs\r\n    gradient: function(type, block) {\r\n      return this.defs().gradient(type, block)\r\n    }\r\n  }\r\n})\r\n\r\n// Add animatable methods to both gradient and fx module\r\nSVG.extend(SVG.Gradient, SVG.FX, {\r\n  // From position\r\n  from: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n  }\r\n  // To position\r\n, to: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n  }\r\n})\r\n\r\n// Base gradient generation\r\nSVG.extend(SVG.Defs, {\r\n  // define gradient\r\n  gradient: function(type, block) {\r\n    return this.put(new SVG.Gradient(type)).update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.Stop = SVG.invent({\r\n  // Initialize node\r\n  create: 'stop'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // add color stops\r\n    update: function(o) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        o = {\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        }\r\n      }\r\n\r\n      // set attributes\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Pattern = SVG.invent({\r\n  // Initialize node\r\n  create: 'pattern'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Return the fill id\r\n    fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Update pattern by rebuilding\r\n  , update: function(block) {\r\n      // remove content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'patternTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create pattern element in defs\r\n    pattern: function(width, height, block) {\r\n      return this.defs().pattern(width, height, block)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Define gradient\r\n  pattern: function(width, height, block) {\r\n    return this.put(new SVG.Pattern).update(block).attr({\r\n      x:            0\r\n    , y:            0\r\n    , width:        width\r\n    , height:       height\r\n    , patternUnits: 'userSpaceOnUse'\r\n    })\r\n  }\r\n\r\n})\nSVG.Doc = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    if (element) {\r\n      // ensure the presence of a dom element\r\n      element = typeof element == 'string' ?\r\n        document.getElementById(element) :\r\n        element\r\n\r\n      // If the target is an svg element, use that element as the main wrapper.\r\n      // This allows svg.js to work with svg documents as well.\r\n      if (element.nodeName == 'svg') {\r\n        this.constructor.call(this, element)\r\n      } else {\r\n        this.constructor.call(this, SVG.create('svg'))\r\n        element.appendChild(this.node)\r\n        this.size('100%', '100%')\r\n      }\r\n\r\n      // set svg element attributes and ensure defs node\r\n      this.namespace().defs()\r\n    }\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add namespaces\r\n    namespace: function() {\r\n      return this\r\n        .attr({ xmlns: SVG.ns, version: '1.1' })\r\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\r\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\r\n    }\r\n    // Creates and returns defs element\r\n  , defs: function() {\r\n      if (!this._defs) {\r\n        var defs\r\n\r\n        // Find or create a defs element in this instance\r\n        if (defs = this.node.getElementsByTagName('defs')[0])\r\n          this._defs = SVG.adopt(defs)\r\n        else\r\n          this._defs = new SVG.Defs\r\n\r\n        // Make sure the defs node is at the end of the stack\r\n        this.node.appendChild(this._defs.node)\r\n      }\r\n\r\n      return this._defs\r\n    }\r\n    // custom parent method\r\n  , parent: function() {\r\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\r\n    }\r\n    // Fix for possible sub-pixel offset. See:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\r\n  , spof: function() {\r\n      var pos = this.node.getScreenCTM()\r\n\r\n      if (pos)\r\n        this\r\n          .style('left', (-pos.e % 1) + 'px')\r\n          .style('top',  (-pos.f % 1) + 'px')\r\n\r\n      return this\r\n    }\r\n\r\n      // Removes the doc from the DOM\r\n  , remove: function() {\r\n      if(this.parent()) {\r\n        this.parent().removeChild(this.node)\r\n      }\r\n\r\n      return this\r\n    }\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      // add back parser\r\n      if(!SVG.parser.draw.parentNode)\r\n        this.node.appendChild(SVG.parser.draw)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Shape = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n})\n\r\nSVG.Bare = SVG.invent({\r\n  // Initialize\r\n  create: function(element, inherit) {\r\n    // construct element\r\n    this.constructor.call(this, SVG.create(element))\r\n\r\n    // inherit custom methods\r\n    if (inherit)\r\n      for (var method in inherit.prototype)\r\n        if (typeof inherit.prototype[method] === 'function')\r\n          this[method] = inherit.prototype[method]\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Insert some plain text\r\n    words: function(text) {\r\n      // remove contents\r\n      while (this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // create text node\r\n      this.node.appendChild(document.createTextNode(text))\r\n\r\n      return this\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Create an element that is not described by SVG.js\r\n  element: function(element, inherit) {\r\n    return this.put(new SVG.Bare(element, inherit))\r\n  }\r\n})\r\n\nSVG.Symbol = SVG.invent({\r\n  // Initialize node\r\n  create: 'symbol'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n, construct: {\r\n    // create symbol\r\n    symbol: function() {\r\n      return this.put(new SVG.Symbol)\r\n    }\r\n  }\r\n})\r\n\nSVG.Use = SVG.invent({\r\n  // Initialize node\r\n  create: 'use'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Use element as a reference\r\n    element: function(element, file) {\r\n      // Set lined element\r\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a use element\r\n    use: function(element, file) {\r\n      return this.put(new SVG.Use).element(element, file)\r\n    }\r\n  }\r\n})\nSVG.Rect = SVG.invent({\r\n  // Initialize node\r\n  create: 'rect'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a rect element\r\n    rect: function(width, height) {\r\n      return this.put(new SVG.Rect()).size(width, height)\r\n    }\r\n  }\r\n})\nSVG.Circle = SVG.invent({\r\n  // Initialize node\r\n  create: 'circle'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create circle element, based on ellipse\r\n    circle: function(size) {\r\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Circle, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('r', rx)\r\n  }\r\n  // Alias radius x value\r\n, ry: function(ry) {\r\n    return this.rx(ry)\r\n  }\r\n})\r\n\r\nSVG.Ellipse = SVG.invent({\r\n  // Initialize node\r\n  create: 'ellipse'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create an ellipse\r\n    ellipse: function(width, height) {\r\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('rx', rx)\r\n  }\r\n  // Radius y value\r\n, ry: function(ry) {\r\n    return this.attr('ry', ry)\r\n  }\r\n})\r\n\r\n// Add common method\r\nSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n    }\r\n    // Custom size function\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .rx(new SVG.Number(p.width).divide(2))\r\n        .ry(new SVG.Number(p.height).divide(2))\r\n    }\r\n})\nSVG.Line = SVG.invent({\r\n  // Initialize node\r\n  create: 'line'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Get array\r\n    array: function() {\r\n      return new SVG.PointArray([\r\n        [ this.attr('x1'), this.attr('y1') ]\r\n      , [ this.attr('x2'), this.attr('y2') ]\r\n      ])\r\n    }\r\n    // Overwrite native plot() method\r\n  , plot: function(x1, y1, x2, y2) {\r\n      if (x1 == null)\r\n        return this.array()\r\n      else if (typeof y1 !== 'undefined')\r\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n      else\r\n        x1 = new SVG.PointArray(x1).toLine()\r\n\r\n      return this.attr(x1)\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr(this.array().move(x, y).toLine())\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr(this.array().size(p.width, p.height).toLine())\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a line element\r\n    line: function(x1, y1, x2, y2) {\r\n      // make sure plot is called as a setter\r\n      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n      return SVG.Line.prototype.plot.apply(\r\n        this.put(new SVG.Line)\r\n      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n      )\r\n    }\r\n  }\r\n})\r\n\nSVG.Polyline = SVG.invent({\r\n  // Initialize node\r\n  create: 'polyline'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polyline element\r\n    polyline: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.Polygon = SVG.invent({\r\n  // Initialize node\r\n  create: 'polygon'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polygon element\r\n    polygon: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\n// Add polygon-specific functions\r\nSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n  // Get array\r\n  array: function() {\r\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n  }\r\n  // Plot new path\r\n, plot: function(p) {\r\n    return (p == null) ?\r\n      this.array() :\r\n      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n  }\r\n  // Clear array cache\r\n, clear: function() {\r\n    delete this._array\r\n    return this\r\n  }\r\n  // Move by left top corner\r\n, move: function(x, y) {\r\n    return this.attr('points', this.array().move(x, y))\r\n  }\r\n  // Set element size to given width and height\r\n, size: function(width, height) {\r\n    var p = proportionalSize(this, width, height)\r\n\r\n    return this.attr('points', this.array().size(p.width, p.height))\r\n  }\r\n\r\n})\r\n\n// unify all point to point elements\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n  // Define morphable array\r\n  morphArray:  SVG.PointArray\r\n  // Move by left top corner over x-axis\r\n, x: function(x) {\r\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n  }\r\n  // Move by left top corner over y-axis\r\n, y: function(y) {\r\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n  }\r\n  // Set width of element\r\n, width: function(width) {\r\n    var b = this.bbox()\r\n\r\n    return width == null ? b.width : this.size(width, b.height)\r\n  }\r\n  // Set height of element\r\n, height: function(height) {\r\n    var b = this.bbox()\r\n\r\n    return height == null ? b.height : this.size(b.width, height)\r\n  }\r\n})\nSVG.Path = SVG.invent({\r\n  // Initialize node\r\n  create: 'path'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Define morphable array\r\n    morphArray:  SVG.PathArray\r\n    // Get array\r\n  , array: function() {\r\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n    }\r\n    // Plot new path\r\n  , plot: function(d) {\r\n      return (d == null) ?\r\n        this.array() :\r\n        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n    }\r\n    // Clear array cache\r\n  , clear: function() {\r\n      delete this._array\r\n      return this\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr('d', this.array().move(x, y))\r\n    }\r\n    // Move by left top corner over x-axis\r\n  , x: function(x) {\r\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n    }\r\n    // Move by left top corner over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr('d', this.array().size(p.width, p.height))\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped path element\r\n    path: function(d) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n    }\r\n  }\r\n})\r\n\nSVG.Image = SVG.invent({\r\n  // Initialize node\r\n  create: 'image'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // (re)load image\r\n    load: function(url) {\r\n      if (!url) return this\r\n\r\n      var self = this\r\n        , img  = new window.Image()\r\n\r\n      // preload image\r\n      SVG.on(img, 'load', function() {\r\n        SVG.off(img)\r\n\r\n        var p = self.parent(SVG.Pattern)\r\n\r\n        if(p === null) return\r\n\r\n        // ensure image size\r\n        if (self.width() == 0 && self.height() == 0)\r\n          self.size(img.width, img.height)\r\n\r\n        // ensure pattern size if not set\r\n        if (p && p.width() == 0 && p.height() == 0)\r\n          p.size(self.width(), self.height())\r\n\r\n        // callback\r\n        if (typeof self._loaded === 'function')\r\n          self._loaded.call(self, {\r\n            width:  img.width\r\n          , height: img.height\r\n          , ratio:  img.width / img.height\r\n          , url:    url\r\n          })\r\n      })\r\n\r\n      SVG.on(img, 'error', function(e){\r\n        SVG.off(img)\r\n\r\n        if (typeof self._error === 'function'){\r\n            self._error.call(self, e)\r\n        }\r\n      })\r\n\r\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n    }\r\n    // Add loaded callback\r\n  , loaded: function(loaded) {\r\n      this._loaded = loaded\r\n      return this\r\n    }\r\n\r\n  , error: function(error) {\r\n      this._error = error\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // create image element, load image and set its size\r\n    image: function(source, width, height) {\r\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n    }\r\n  }\r\n\r\n})\nSVG.Text = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('text'))\r\n\r\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n    this._rebuild = true                      // enable automatic updating of dy values\r\n    this._build   = false                     // disable build mode for adding multiple lines\r\n\r\n    // set default font\r\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      // act as getter\r\n      if (x == null)\r\n        return this.attr('x')\r\n\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      var oy = this.attr('y')\r\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\r\n      // act as getter\r\n      if (y == null)\r\n        return typeof oy === 'number' ? oy - o : oy\r\n\r\n      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n    }\r\n    // Move center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n    }\r\n    // Move center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n    }\r\n    // Set the text content\r\n  , text: function(text) {\r\n      // act as getter\r\n      if (typeof text === 'undefined'){\r\n        var text = ''\r\n        var children = this.node.childNodes\r\n        for(var i = 0, len = children.length; i < len; ++i){\r\n\r\n          // add newline if its not the first child and newLined is set to true\r\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n            text += '\\n'\r\n          }\r\n\r\n          // add content of this node\r\n          text += children[i].textContent\r\n        }\r\n\r\n        return text\r\n      }\r\n\r\n      // remove existing content\r\n      this.clear().build(true)\r\n\r\n      if (typeof text === 'function') {\r\n        // call block\r\n        text.call(this, this)\r\n\r\n      } else {\r\n        // store text and make sure text is not blank\r\n        text = text.split('\\n')\r\n\r\n        // build new lines\r\n        for (var i = 0, il = text.length; i < il; i++)\r\n          this.tspan(text[i]).newLine()\r\n      }\r\n\r\n      // disable build mode and rebuild lines\r\n      return this.build(false).rebuild()\r\n    }\r\n    // Set font size\r\n  , size: function(size) {\r\n      return this.attr('font-size', size).rebuild()\r\n    }\r\n    // Set / get leading\r\n  , leading: function(value) {\r\n      // act as getter\r\n      if (value == null)\r\n        return this.dom.leading\r\n\r\n      // act as setter\r\n      this.dom.leading = new SVG.Number(value)\r\n\r\n      return this.rebuild()\r\n    }\r\n    // Get all the first level lines\r\n  , lines: function() {\r\n      var node = (this.textPath && this.textPath() || this).node\r\n\r\n      // filter tspans and map them to SVG.js instances\r\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n        return SVG.adopt(el)\r\n      })\r\n\r\n      // return an instance of SVG.set\r\n      return new SVG.Set(lines)\r\n    }\r\n    // Rebuild appearance type\r\n  , rebuild: function(rebuild) {\r\n      // store new rebuild flag if given\r\n      if (typeof rebuild == 'boolean')\r\n        this._rebuild = rebuild\r\n\r\n      // define position of all lines\r\n      if (this._rebuild) {\r\n        var self = this\r\n          , blankLineOffset = 0\r\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n\r\n        this.lines().each(function() {\r\n          if (this.dom.newLined) {\r\n            if (!self.textPath())\r\n              this.attr('x', self.attr('x'))\r\n            if(this.text() == '\\n') {\r\n              blankLineOffset += dy\r\n            }else{\r\n              this.attr('dy', dy + blankLineOffset)\r\n              blankLineOffset = 0\r\n            }\r\n          }\r\n        })\r\n\r\n        this.fire('rebuild')\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Enable / disable build mode\r\n  , build: function(build) {\r\n      this._build = !!build\r\n      return this\r\n    }\r\n    // overwrite method from parent to set data properly\r\n  , setData: function(o){\r\n      this.dom = o\r\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create text element\r\n    text: function(text) {\r\n      return this.put(new SVG.Text).text(text)\r\n    }\r\n    // Create plain text element\r\n  , plain: function(text) {\r\n      return this.put(new SVG.Text).plain(text)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Tspan = SVG.invent({\r\n  // Initialize node\r\n  create: 'tspan'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set text content\r\n    text: function(text) {\r\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\r\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\r\n      return this\r\n    }\r\n    // Shortcut dx\r\n  , dx: function(dx) {\r\n      return this.attr('dx', dx)\r\n    }\r\n    // Shortcut dy\r\n  , dy: function(dy) {\r\n      return this.attr('dy', dy)\r\n    }\r\n    // Create new line\r\n  , newLine: function() {\r\n      // fetch text parent\r\n      var t = this.parent(SVG.Text)\r\n\r\n      // mark new line\r\n      this.dom.newLined = true\r\n\r\n      // apply new hyn\r\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Text, SVG.Tspan, {\r\n  // Create plain text node\r\n  plain: function(text) {\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // create text node\r\n    this.node.appendChild(document.createTextNode(text))\r\n\r\n    return this\r\n  }\r\n  // Create a tspan\r\n, tspan: function(text) {\r\n    var node  = (this.textPath && this.textPath() || this).node\r\n      , tspan = new SVG.Tspan\r\n\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // add new tspan\r\n    node.appendChild(tspan.node)\r\n\r\n    return tspan.text(text)\r\n  }\r\n  // Clear all lines\r\n, clear: function() {\r\n    var node = (this.textPath && this.textPath() || this).node\r\n\r\n    // remove existing child nodes\r\n    while (node.hasChildNodes())\r\n      node.removeChild(node.lastChild)\r\n\r\n    return this\r\n  }\r\n  // Get length of text element\r\n, length: function() {\r\n    return this.node.getComputedTextLength()\r\n  }\r\n})\r\n\nSVG.TextPath = SVG.invent({\r\n  // Initialize node\r\n  create: 'textPath'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n  // Define parent class\r\n, parent: SVG.Text\r\n\r\n  // Add parent method\r\n, construct: {\r\n    morphArray: SVG.PathArray\r\n    // Create path for text to run on\r\n  , path: function(d) {\r\n      // create textPath element\r\n      var path  = new SVG.TextPath\r\n        , track = this.doc().defs().path(d)\r\n\r\n      // move lines to textpath\r\n      while (this.node.hasChildNodes())\r\n        path.node.appendChild(this.node.firstChild)\r\n\r\n      // add textPath element as child node\r\n      this.node.appendChild(path.node)\r\n\r\n      // link textPath to path and add content\r\n      path.attr('href', '#' + track, SVG.xlink)\r\n\r\n      return this\r\n    }\r\n    // return the array of the path track element\r\n  , array: function() {\r\n      var track = this.track()\r\n\r\n      return track ? track.array() : null\r\n    }\r\n    // Plot path if any\r\n  , plot: function(d) {\r\n      var track = this.track()\r\n        , pathArray = null\r\n\r\n      if (track) {\r\n        pathArray = track.plot(d)\r\n      }\r\n\r\n      return (d == null) ? pathArray : this\r\n    }\r\n    // Get the path track element\r\n  , track: function() {\r\n      var path = this.textPath()\r\n\r\n      if (path)\r\n        return path.reference('href')\r\n    }\r\n    // Get the textPath child\r\n  , textPath: function() {\r\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n        return SVG.adopt(this.node.firstChild)\r\n    }\r\n  }\r\n})\r\n\nSVG.Nested = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('svg'))\r\n\r\n    this.style('overflow', 'visible')\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create nested svg document\r\n    nested: function() {\r\n      return this.put(new SVG.Nested)\r\n    }\r\n  }\r\n})\nSVG.A = SVG.invent({\r\n  // Initialize node\r\n  create: 'a'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Link url\r\n    to: function(url) {\r\n      return this.attr('href', url, SVG.xlink)\r\n    }\r\n    // Link show attribute\r\n  , show: function(target) {\r\n      return this.attr('show', target, SVG.xlink)\r\n    }\r\n    // Link target attribute\r\n  , target: function(target) {\r\n      return this.attr('target', target)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a hyperlink element\r\n    link: function(url) {\r\n      return this.put(new SVG.A).to(url)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Create a hyperlink element\r\n  linkTo: function(url) {\r\n    var link = new SVG.A\r\n\r\n    if (typeof url == 'function')\r\n      url.call(link, link)\r\n    else\r\n      link.to(url)\r\n\r\n    return this.parent().put(link).put(this)\r\n  }\r\n\r\n})\nSVG.Marker = SVG.invent({\r\n  // Initialize node\r\n  create: 'marker'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set width of element\r\n    width: function(width) {\r\n      return this.attr('markerWidth', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('markerHeight', height)\r\n    }\r\n    // Set marker refX and refY\r\n  , ref: function(x, y) {\r\n      return this.attr('refX', x).attr('refY', y)\r\n    }\r\n    // Update marker\r\n  , update: function(block) {\r\n      // remove all content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , toString: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    marker: function(width, height, block) {\r\n      // Create marker element in defs\r\n      return this.defs().marker(width, height, block)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Create marker\r\n  marker: function(width, height, block) {\r\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n    return this.put(new SVG.Marker)\r\n      .size(width, height)\r\n      .ref(width / 2, height / 2)\r\n      .viewbox(0, 0, width, height)\r\n      .attr('orient', 'auto')\r\n      .update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n  // Create and attach markers\r\n  marker: function(marker, width, height, block) {\r\n    var attr = ['marker']\r\n\r\n    // Build attribute name\r\n    if (marker != 'all') attr.push(marker)\r\n    attr = attr.join('-')\r\n\r\n    // Set marker attribute\r\n    marker = arguments[1] instanceof SVG.Marker ?\r\n      arguments[1] :\r\n      this.doc().marker(width, height, block)\r\n\r\n    return this.attr(attr, marker)\r\n  }\r\n\r\n})\n// Define list of available attributes for stroke and fill\r\nvar sugar = {\r\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n, fill:   ['color', 'opacity', 'rule']\r\n, prefix: function(t, a) {\r\n    return a == 'color' ? t : t + '-' + a\r\n  }\r\n}\r\n\r\n// Add sugar for fill and stroke\r\n;['fill', 'stroke'].forEach(function(m) {\r\n  var i, extension = {}\r\n\r\n  extension[m] = function(o) {\r\n    if (typeof o == 'undefined')\r\n      return this\r\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n      this.attr(m, o)\r\n\r\n    else\r\n      // set all attributes from sugar.fill and sugar.stroke list\r\n      for (i = sugar[m].length - 1; i >= 0; i--)\r\n        if (o[sugar[m][i]] != null)\r\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\r\n    return this\r\n  }\r\n\r\n  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, SVG.FX, {\r\n  // Map rotation to transform\r\n  rotate: function(d, cx, cy) {\r\n    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n  }\r\n  // Map skew to transform\r\n, skew: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ skew: x, cx: y, cy: cx }) :\r\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map scale to transform\r\n, scale: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ scale: x, cx: y, cy: cx }) :\r\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map translate to transform\r\n, translate: function(x, y) {\r\n    return this.transform({ x: x, y: y })\r\n  }\r\n  // Map flip to transform\r\n, flip: function(a, o) {\r\n    o = typeof a == 'number' ? a : o\r\n    return this.transform({ flip: a || 'both', offset: o })\r\n  }\r\n  // Map matrix to transform\r\n, matrix: function(m) {\r\n    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n  }\r\n  // Opacity\r\n, opacity: function(value) {\r\n    return this.attr('opacity', value)\r\n  }\r\n  // Relative move over x axis\r\n, dx: function(x) {\r\n    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n  }\r\n  // Relative move over y axis\r\n, dy: function(y) {\r\n    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n  }\r\n  // Relative move over x and y axes\r\n, dmove: function(x, y) {\r\n    return this.dx(x).dy(y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n  // Add x and y radius\r\n  radius: function(x, y) {\r\n    var type = (this._target || this).type;\r\n    return type == 'radial' || type == 'circle' ?\r\n      this.attr('r', new SVG.Number(x)) :\r\n      this.rx(x).ry(y == null ? x : y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Path, {\r\n  // Get path length\r\n  length: function() {\r\n    return this.node.getTotalLength()\r\n  }\r\n  // Get point at length\r\n, pointAt: function(length) {\r\n    return this.node.getPointAtLength(length)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n  // Set font\r\n  font: function(a, v) {\r\n    if (typeof a == 'object') {\r\n      for (v in a) this.font(v, a[v])\r\n    }\r\n\r\n    return a == 'leading' ?\r\n        this.leading(v) :\r\n      a == 'anchor' ?\r\n        this.attr('text-anchor', v) :\r\n      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n        this.attr('font-'+ a, v) :\r\n        this.attr(a, v)\r\n  }\r\n})\r\n\nSVG.Set = SVG.invent({\r\n  // Initialize\r\n  create: function(members) {\r\n    // Set initial state\r\n    Array.isArray(members) ? this.members = members : this.clear()\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add element to set\r\n    add: function() {\r\n      var i, il, elements = [].slice.call(arguments)\r\n\r\n      for (i = 0, il = elements.length; i < il; i++)\r\n        this.members.push(elements[i])\r\n\r\n      return this\r\n    }\r\n    // Remove element from set\r\n  , remove: function(element) {\r\n      var i = this.index(element)\r\n\r\n      // remove given child\r\n      if (i > -1)\r\n        this.members.splice(i, 1)\r\n\r\n      return this\r\n    }\r\n    // Iterate over all members\r\n  , each: function(block) {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        block.apply(this.members[i], [i, this.members])\r\n\r\n      return this\r\n    }\r\n    // Restore to defaults\r\n  , clear: function() {\r\n      // initialize store\r\n      this.members = []\r\n\r\n      return this\r\n    }\r\n    // Get the length of a set\r\n  , length: function() {\r\n      return this.members.length\r\n    }\r\n    // Checks if a given element is present in set\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // retuns index of given element in set\r\n  , index: function(element) {\r\n      return this.members.indexOf(element)\r\n    }\r\n    // Get member at given index\r\n  , get: function(i) {\r\n      return this.members[i]\r\n    }\r\n    // Get first member\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get last member\r\n  , last: function() {\r\n      return this.get(this.members.length - 1)\r\n    }\r\n    // Default value\r\n  , valueOf: function() {\r\n      return this.members\r\n    }\r\n    // Get the bounding box of all members included or empty box if set has no items\r\n  , bbox: function(){\r\n      // return an empty box of there are no members\r\n      if (this.members.length == 0)\r\n        return new SVG.RBox()\r\n\r\n      // get the first rbox and update the target bbox\r\n      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\r\n      this.each(function() {\r\n        // user rbox for correct position and visual representation\r\n        rbox = rbox.merge(this.rbox(this.doc()))\r\n      })\r\n\r\n      return rbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a new set\r\n    set: function(members) {\r\n      return new SVG.Set(members)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.FX.Set = SVG.invent({\r\n  // Initialize node\r\n  create: function(set) {\r\n    // store reference to set\r\n    this.set = set\r\n  }\r\n\r\n})\r\n\r\n// Alias methods\r\nSVG.Set.inherit = function() {\r\n  var m\r\n    , methods = []\r\n\r\n  // gather shape methods\r\n  for(var m in SVG.Shape.prototype)\r\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply shape aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n          this.members[i][method].apply(this.members[i], arguments)\r\n\r\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n    }\r\n  })\r\n\r\n  // clear methods for the next round\r\n  methods = []\r\n\r\n  // gather fx methods\r\n  for(var m in SVG.FX.prototype)\r\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply fx aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.FX.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\r\n      return this\r\n    }\r\n  })\r\n}\r\n\r\n\r\n\n\r\nSVG.extend(SVG.Element, {\r\n  // Store data values on svg nodes\r\n  data: function(a, v, r) {\r\n    if (typeof a == 'object') {\r\n      for (v in a)\r\n        this.data(v, a[v])\r\n\r\n    } else if (arguments.length < 2) {\r\n      try {\r\n        return JSON.parse(this.attr('data-' + a))\r\n      } catch(e) {\r\n        return this.attr('data-' + a)\r\n      }\r\n\r\n    } else {\r\n      this.attr(\r\n        'data-' + a\r\n      , v === null ?\r\n          null :\r\n        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n          v :\r\n          JSON.stringify(v)\r\n      )\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Remember arbitrary data\r\n  remember: function(k, v) {\r\n    // remember every item in an object individually\r\n    if (typeof arguments[0] == 'object')\r\n      for (var v in k)\r\n        this.remember(v, k[v])\r\n\r\n    // retrieve memory\r\n    else if (arguments.length == 1)\r\n      return this.memory()[k]\r\n\r\n    // store memory\r\n    else\r\n      this.memory()[k] = v\r\n\r\n    return this\r\n  }\r\n\r\n  // Erase a given memory\r\n, forget: function() {\r\n    if (arguments.length == 0)\r\n      this._memory = {}\r\n    else\r\n      for (var i = arguments.length - 1; i >= 0; i--)\r\n        delete this.memory()[arguments[i]]\r\n\r\n    return this\r\n  }\r\n\r\n  // Initialize or return local memory object\r\n, memory: function() {\r\n    return this._memory || (this._memory = {})\r\n  }\r\n\r\n})\n// Method for getting an element by id\r\nSVG.get = function(id) {\r\n  var node = document.getElementById(idFromReference(id) || id)\r\n  return SVG.adopt(node)\r\n}\r\n\r\n// Select elements by query string\r\nSVG.select = function(query, parent) {\r\n  return new SVG.Set(\r\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n      return SVG.adopt(node)\r\n    })\r\n  )\r\n}\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Scoped select method\r\n  select: function(query) {\r\n    return SVG.select(query, this.node)\r\n  }\r\n\r\n})\nfunction pathRegReplace(a, b, c, d) {\r\n  return c + d.replace(SVG.regex.dots, ' .')\r\n}\r\n\r\n// creates deep clone of array\r\nfunction array_clone(arr){\r\n  var clone = arr.slice(0)\r\n  for(var i = clone.length; i--;){\r\n    if(Array.isArray(clone[i])){\r\n      clone[i] = array_clone(clone[i])\r\n    }\r\n  }\r\n  return clone\r\n}\r\n\r\n// tests if a given element is instance of an object\r\nfunction is(el, obj){\r\n  return el instanceof obj\r\n}\r\n\r\n// tests if a given selector matches an element\r\nfunction matches(el, selector) {\r\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n}\r\n\r\n// Convert dash-separated-string to camelCase\r\nfunction camelCase(s) {\r\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n    return g.toUpperCase()\r\n  })\r\n}\r\n\r\n// Capitalize first letter of a string\r\nfunction capitalize(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\n// Ensure to six-based hex\r\nfunction fullHex(hex) {\r\n  return hex.length == 4 ?\r\n    [ '#',\r\n      hex.substring(1, 2), hex.substring(1, 2)\r\n    , hex.substring(2, 3), hex.substring(2, 3)\r\n    , hex.substring(3, 4), hex.substring(3, 4)\r\n    ].join('') : hex\r\n}\r\n\r\n// Component to hex value\r\nfunction compToHex(comp) {\r\n  var hex = comp.toString(16)\r\n  return hex.length == 1 ? '0' + hex : hex\r\n}\r\n\r\n// Calculate proportional width and height values when necessary\r\nfunction proportionalSize(element, width, height) {\r\n  if (width == null || height == null) {\r\n    var box = element.bbox()\r\n\r\n    if (width == null)\r\n      width = box.width / box.height * height\r\n    else if (height == null)\r\n      height = box.height / box.width * width\r\n  }\r\n\r\n  return {\r\n    width:  width\r\n  , height: height\r\n  }\r\n}\r\n\r\n// Delta transform point\r\nfunction deltaTransformPoint(matrix, x, y) {\r\n  return {\r\n    x: x * matrix.a + y * matrix.c + 0\r\n  , y: x * matrix.b + y * matrix.d + 0\r\n  }\r\n}\r\n\r\n// Map matrix array to object\r\nfunction arrayToMatrix(a) {\r\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n}\r\n\r\n// Parse matrix if required\r\nfunction parseMatrix(matrix) {\r\n  if (!(matrix instanceof SVG.Matrix))\r\n    matrix = new SVG.Matrix(matrix)\r\n\r\n  return matrix\r\n}\r\n\r\n// Add centre point to transform object\r\nfunction ensureCentre(o, target) {\r\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n}\r\n\r\n// PathArray Helpers\r\nfunction arrayToString(a) {\r\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n    s += a[i][0]\r\n\r\n    if (a[i][1] != null) {\r\n      s += a[i][1]\r\n\r\n      if (a[i][2] != null) {\r\n        s += ' '\r\n        s += a[i][2]\r\n\r\n        if (a[i][3] != null) {\r\n          s += ' '\r\n          s += a[i][3]\r\n          s += ' '\r\n          s += a[i][4]\r\n\r\n          if (a[i][5] != null) {\r\n            s += ' '\r\n            s += a[i][5]\r\n            s += ' '\r\n            s += a[i][6]\r\n\r\n            if (a[i][7] != null) {\r\n              s += ' '\r\n              s += a[i][7]\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return s + ' '\r\n}\r\n\r\n// Deep new id assignment\r\nfunction assignNewId(node) {\r\n  // do the same for SVG child nodes as well\r\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n    if (node.childNodes[i] instanceof window.SVGElement)\r\n      assignNewId(node.childNodes[i])\r\n\r\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n}\r\n\r\n// Add more bounding box properties\r\nfunction fullBox(b) {\r\n  if (b.x == null) {\r\n    b.x      = 0\r\n    b.y      = 0\r\n    b.width  = 0\r\n    b.height = 0\r\n  }\r\n\r\n  b.w  = b.width\r\n  b.h  = b.height\r\n  b.x2 = b.x + b.width\r\n  b.y2 = b.y + b.height\r\n  b.cx = b.x + b.width / 2\r\n  b.cy = b.y + b.height / 2\r\n\r\n  return b\r\n}\r\n\r\n// Get id from reference string\r\nfunction idFromReference(url) {\r\n  var m = url.toString().match(SVG.regex.reference)\r\n\r\n  if (m) return m[1]\r\n}\r\n\r\n// Create matrix array for looping\r\nvar abcdef = 'abcdef'.split('')\n// Add CustomEvent to IE9 and IE10\r\nif (typeof window.CustomEvent !== 'function') {\r\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n  var CustomEvent = function(event, options) {\r\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n    var e = document.createEvent('CustomEvent')\r\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n    return e\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype\r\n\r\n  window.CustomEvent = CustomEvent\r\n}\r\n\r\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n(function(w) {\r\n  var lastTime = 0\r\n  var vendors = ['moz', 'webkit']\r\n\r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n  }\r\n\r\n  w.requestAnimationFrame = w.requestAnimationFrame ||\r\n    function(callback) {\r\n      var currTime = new Date().getTime()\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n\r\n      var id = w.setTimeout(function() {\r\n        callback(currTime + timeToCall)\r\n      }, timeToCall)\r\n\r\n      lastTime = currTime + timeToCall\r\n      return id\r\n    }\r\n\r\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\r\n}(window))\r\n\r\nreturn SVG\r\n\r\n}));\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/svg.js/dist/svg.js\n// module id = 2\n// module chunks = 0","\"use strict\";\r\n\r\nimport \"./styles/game.css\";\r\n// import Game from \"./partials/Game\";\r\nimport * as SVG from \"svg.js\"\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", function() {\r\n    // code...\r\n\r\n    const svg = SVG(\"game\").size(300, 300);\r\n    var rect = svg.rect(100, 100).attr({ fill: '#f06' });\r\n\r\n});\r\n\r\n\r\n\r\n\r\n// other work here...\r\n\r\n//let draw = svg(\"game-board-svg\");\r\n\r\n\r\n\r\n\r\n// // create a game instance\r\n// const gameElement = document.getElementById(\"game\");\r\n// const game = new Game(gameElement, gameElement.clientWidth, gameElement.clientHeight);\r\n\r\n// (function gameLoop() {\r\n//     game.render();\r\n//     requestAnimationFrame(gameLoop);\r\n// })();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:\\\"\\\";content:none}table{border-collapse:collapse;border-spacing:0}@font-face{font-family:Silkscreen Web;src:url(\" + require(\"../../public/fonts/slkscr-webfont.eot\") + \");src:url(\" + require(\"../../public/fonts/slkscr-webfont.eot\") + \"?#iefix) format(\\\"embedded-opentype\\\"),url(\" + require(\"../../public/fonts/slkscr-webfont.woff\") + \") format(\\\"woff\\\"),url(\" + require(\"../../public/fonts/slkscr-webfont.ttf\") + \") format(\\\"truetype\\\"),url(\" + require(\"../../public/fonts/slkscr-webfont.svg\") + \"#silkscreennormal) format(\\\"svg\\\");font-weight:400;font-style:normal}html{font-size:16px}body{align-items:center;display:flex;font-family:Silkscreen Web,monotype;height:100vh;justify-content:center;width:100%}h1{font-size:2.5rem;margin-bottom:1rem;text-align:center}.game-board svg{background:#353535;color:#fff;stroke:#fff;fill:#fff}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./src/styles/game.css\n// module id = 4\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 5\n// module chunks = 0","module.exports = __webpack_public_path__ + \"public/fonts/slkscr-webfont.svg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/fonts/slkscr-webfont.svg\n// module id = 6\n// module chunks = 0","module.exports = __webpack_public_path__ + \"public/fonts/slkscr-webfont.ttf\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/fonts/slkscr-webfont.ttf\n// module id = 7\n// module chunks = 0","module.exports = __webpack_public_path__ + \"public/fonts/slkscr-webfont.woff\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/fonts/slkscr-webfont.woff\n// module id = 8\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}